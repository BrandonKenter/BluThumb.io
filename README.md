<p align="center">
    <h1 align="center">BluThumb.io     
 </h1>

  <p align="center">
    An all-in-one platform that facilitates reviewing LeetCode problems with spaced repetition.
    <br>
    <a href="https://bluthumb.io/"><strong>Check it out here Â»</strong></a>
  </p>
</p>

![portfolio-preview](https://github.com/BrandonKenter/BluThumb.io/blob/main/bluthumb-preview2.png)


## The purpose of this repo

BluThumb.io hosts a curated list of 300 problems called BluThumb 300. This list of problems was selected from a collection of notes I wrote for over 1000 LeetCode problems. As abundantly described on BluThumb.io, breaking down the common patterns into subpatterns allows us to create a better mental model for seeing new problems, identifying possible approaches, and arriving at a solution. Below is a breakdown of all the problems in BluThumb 300, with some notes accompanying most of them.

Open the README.md file to see all 300 problems.

## Tree

|Pre-order Traversal                                                              |:lemon:|                                                                                                                                                                                           |                                                                                                                                                                                                                                                      |                                                         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |                                                                                                                                                                                                                                                                                            |
|---------------------------------------------------------------------------------|-------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|Tree / Binary Tree / Depth-First Search / Recursion                              |E      |[](https://leetcode.com/problems/binary-tree-preorder-traversal/)[144](https://leetcode.com/problems/binary-tree-preorder-traversal/)                                                      |[](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC144-binaryTreePreorderTraversal.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC144-binaryTreePreorderTraversal.py)                                              |Binary Tree Preorder Traversal                           |Preorder traversal traverses the tree structure in this order: Root -> Left -> Right. One aspect of preorder/inorder/postorder traversal that might not be immediately obvious is we are processing subtrees in the same order as a parent-children subtree. So from the root we process the root and then the whole left subtree then the whole right subtree. And also at a leaf node we process the leaf, then the left child, then the right child. This understanding is important for many problems that require you to do/calculate something from each subtree.                                                                                                                                                                                                                                                                                                                             |Concept: 1) Use preorder traversal to print the nodes in a preorder fashion.                                                                                                                                                                                                                |
|Tree / N-ary Tree / Depth-First Search / Recursion                               |E      |[](https://leetcode.com/problems/n-ary-tree-preorder-traversal/)[589](https://leetcode.com/problems/n-ary-tree-preorder-traversal/)                                                        |[](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC589-N-aryTreePreorderTraversal.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC589-N-aryTreePreorderTraversal.py)                                                |N-ary Tree Preorder Traversal                            |The space complexity is dependent on what someone considers to be extra space. Some people say data structures that store the output values are considered a part of the space complexity, while others don't. If the output array is counted, it is O(N) space copmlexity. If not, it is O(H) where H is the height of the tree (for the call stack). If an iterate BFS is done, it's always O(N) because the max size of the level in the BFS will have about N nodes in the queue. These tradeoffs are important to understand and should be able to be articulated in an interview.                                                                                                                                                                                                                                                                                                             |Concept: 1) Use pre-order traversal to traverse an n-ary tree.                                                                                                                                                                                                                              |
|Tree / Binary Tree / Depth-First Search / Recursion                              |E      |[](https://leetcode.com/problems/merge-two-binary-trees/)[617](https://leetcode.com/problems/merge-two-binary-trees/)                                                                      |                                                                                                                                                                                                                                                      |Merge Two Binary Trees                                   |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |Concept: 1) Preorder traversal. 2) Traverse two trees at the same time in the same positions even if one tree does not have a node in this position.                                                                                                                                        |
|Tree / Binary Tree / Depth-First Search / Recursion                              |E      |[](https://leetcode.com/problems/same-tree/)[100](https://leetcode.com/problems/same-tree/)                                                                                                |[](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC100-sameTree.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC100-sameTree.py)                                                                                    |Same Tree                                                |We might prefer the iterative DFS or BFS approach over the recursive DFS approach if stack space is an issue. Otherwise, the recursive DFS implementation Is way more clean and concise. If the tree is height-balanced, space complexity is O(logn) for the call stack of the DFS implementation. It is worth noting that I almost always omit iterative DFS solutions from explanations because the translation is trivial in most cases.                                                                                                                                                                                                                                                                                                                                                                                                                                                         |Concept: 1) Use preorder traversal on two trees simultaneously, comparing the node values at each node. 2) Use boolean evaluation.                                                                                                                                                          |
|Tree / Binary Tree / Depth-First Search / Recursion                              |M      |[](https://leetcode.com/problems/count-good-nodes-in-binary-tree/)[1448](https://leetcode.com/problems/count-good-nodes-in-binary-tree/)                                                   |[](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC1448-countGoodNodesInBinaryTree.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC1448-countGoodNodesInBinaryTree.py)                                              |Count Good Nodes in Binary Tree                          |This is a standard DFS traversal problem of a tree with a subpattern of keeping track of a count outside of the nested function and returning nothing from the DFS. It is a preorder traversal because we process the current node, then dfs on left then dfs on right. Notice how path_max is passed by value, so each execution context gets its own copy of path_max.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |Concept: 1) Use pre-order traversal to evaluate if the path to the current node has no nodes with a value greater than it.                                                                                                                                                                  |
|Tree / Binary Tree / Depth-First Search                                          |E      |[](https://leetcode.com/problems/binary-tree-paths/)[257](https://leetcode.com/problems/binary-tree-paths/)                                                                                |[](https://github.com/BrandonKenter/Solutions/blob/main/Tree/binaryTreePaths.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/binaryTreePaths.py)                                                                                  |Binary Tree Paths                                        |Cur_path is a list so in python it is passed by reference. This means that every execution context for each recursive call gets a reference to the same list. So when the call stack pops back up, we are still pointing ot the list that has that extra node in it. So we pop from cur_path to make sure each execution context has the corresponding path. The space complexity O(H) is for the call stack. If we consider the output array paths, then it would be closer to O(N\*H) since there can be about N paths of height H.                                                                                                                                                                                                                                                                                                                                                               |Concept: 1) Use preorder traversal to print each root to leaf path. 2) Build the current path using a list parameter and preorder traversal (add to path first, then check if this node is a leaf). 3) Check if node is a leaf node.                                                        |
|In-order Traversal                                                               |:lemon:|                                                                                                                                                                                           |                                                                                                                                                                                                                                                      |                                                         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |                                                                                                                                                                                                                                                                                            |
|Tree / Binary Tree / Depth-First Search / Recursion                              |E      |[](https://leetcode.com/problems/binary-tree-inorder-traversal/)[94](https://leetcode.com/problems/binary-tree-inorder-traversal/)                                                         |[](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC94-binaryTreeInorderTraversal.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC94-binaryTreeInorderTraversal.py)                                                  |Binary Tree Inorder Traversal                            |Inorder traversal traverses a tree structure in a Left -> Root -> Right sequence. The code might be hard to trace if you are not familiar with recursion. The visual of the code doesn't really reflect what is happening during program execution. I recommend watching a video that goes through the traversal if you are not able to visualize each step of the traversal.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |Concept: 1) Use in-order traversal to print the nodes in an in-order fashion.                                                                                                                                                                                                               |
|Tree / Binary Tree / Depth-First Search / Recursion                              |E      |[](https://leetcode.com/problems/minimum-distance-between-bst-nodes/)[783](https://leetcode.com/problems/minimum-distance-between-bst-nodes/)                                              |[](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC783-minimumDistanceBetweenBSTNodes.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC783-minimumDistanceBetweenBSTNodes.py)                                        |Minimum Distance Between BST Nodes                       |The reason we do an inorder traversal is because the minimum difference between two nodes will always be between two nodes that are adjacent in sorted order. This similar to LC 285, but we are checking all successors, so a full inorder traversal is necessary. The reason we use a nonlocal variable outside of the dfs function is because the adjacent values aren't always directly connected by one edge, so we can't use something like a parent reference and must keep track of the last evaluated node. Think of how inorder works. Left -> Root -> Right. So it goes deep left, processes left, processes root, then processes right. The next value in the inorder traversal if there a more nodes in the tree is right's parent's parent, since right is in the left subtree of the Left -> Root -> Right traversal.                                                                |Concept: 1) Use in-order traversal with a nonlocal variable tracking the previous node's value to find the minimum difference between two nodes.                                                                                                                                            |
|Tree / Binary Tree / Depth-First Search / Recursion                              |M      |[](https://leetcode.com/problems/binary-search-tree-iterator/)[173](https://leetcode.com/problems/binary-search-tree-iterator/)                                                            |[](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC173-binarySearchTreeIterator.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC173-binarySearchTreeIterator.py)                                                    |Binary Search Tree Iterator                              |To suspend the iterator on the next node, use a stack and populate it with all left nodes until we reach a null node. Then when next() is called, popping the node at the top of the stack will be the next node in the iterator. Then get the node's right reference (if it is not None) and again traverse down to the left, adding each node to the stack. This acts like inorder DFS where we suspend the iterator at the next node.                                                                                                                                                                                                                                                                                                                                                                                                                                                            |Concept: 1) Use a stack to implement iterative in-order traversal.                                                                                                                                                                                                                          |
|Post-order Traversal                                                             |:lemon:|                                                                                                                                                                                           |                                                                                                                                                                                                                                                      |                                                         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |                                                                                                                                                                                                                                                                                            |
|Tree / Binary Tree / Depth-First Search / Recursion                              |E      |[](https://leetcode.com/problems/binary-tree-postorder-traversal/)[145](https://leetcode.com/problems/binary-tree-postorder-traversal/)                                                    |[](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC145-binaryTreePostorderTraversal.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC145-binaryTreePostorderTraversal.py)                                            |Binary Tree Postorder Traversal                          |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |Concept: 1) Use post-order traversal to print the nodes in a tree in a post-order fashion.                                                                                                                                                                                                  |
|Tree / Binary Tree / Depth-First Search / Recursion                              |E      |[](https://leetcode.com/problems/balanced-binary-tree/)[110](https://leetcode.com/problems/balanced-binary-tree/)                                                                          |[](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC110-balancedBinaryTree.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC110-balancedBinaryTree.py)                                                                |Balanced Binary Tree                                     |A somewhat tricky thing to come up with is returning a pair of values for each recursive call. Also note that this approach requires a helper function because isBalanced() returns a bool. So we can't use isBalanced() to pass the pair of values up the tree during recursion and eventually to the original caller which only wants a bool value.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |Concept: 1) Use post-order traversal to compare subtree heights.                                                                                                                                                                                                                            |
|Tree / Binary Tree / Depth-First Search / Recursion                              |M      |[](https://leetcode.com/problems/delete-leaves-with-a-given-value/description/)[1325](https://leetcode.com/problems/delete-leaves-with-a-given-value/description/)                         |[](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC1325-deleteLeavesWithAGivenValue.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC1325-deleteLeavesWithAGivenValue.py)                                            |Delete Leaves With a Given Value                         |Use a postorder traversal. We want postorder so we can remove references of leaf nodes that match the target value starting from the bottom and going up. Since we are reassigning references, we can recursively set root.left and root.right to the respective DFS calls. And since we are assigning infromation to each child, we must return some information. And that infromation is the children nodes. So we encode the case that we want to delete by returning None, which will in turn set root.left or root.right to None if they should be deleted. Otherwise, we return root. And the base case returns None if root is None because we want root.left/root.right to be assigned to None if there is no node.                                                                                                                                                                         |Concept: 1) Use post-order traversal to delete leaf nodes that match a target value. 2) Deleting a leaf node can make its parent a leaf node, making a bottom-up order beneficial.                                                                                                          |
|Tree / Binary Tree / Depth-First Search / Recursion                              |M      |[](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/)[236](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/)                                    |[](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC236-lowestCommonAncestorOfABinaryTree.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC236-lowestCommonAncestorOfABinaryTree.py)                                  |Lowest Common Ancestor of a Binary Tree                  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |Concept: 1) Use post-order traversal to find the LCA of two nodes.                                                                                                                                                                                                                          |
|Tree / Binary Tree / Depth-First Search / Recursion                              |M      |[](https://leetcode.com/problems/count-nodes-equal-to-average-of-subtree/)[2265](https://leetcode.com/problems/count-nodes-equal-to-average-of-subtree/)                                   |[](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC2265-countNodesEqualToAverageOfSubtree.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC2265-countNodesEqualToAverageOfSubtree.py)                                |Count Nodes Equal to Average of Subtree                  |This is a problem that follows the subpattern of processing nodes in a postorder manner. We recurse deeply on the left, then on the right, store whatever information we get from the left and right subtrees into variables, and then use the left and right subtree values we found to compute what the problem is asking for. Important things to note for these types of problems: 1) We return a value in the recursion (a pair of values in this case) even in the base case. 2) We do a preorder traversal and store the values returned by the left and right subtrees in variables 'left' and 'right'. 3) We do a computation on the information we found in the two subtrees. 4) We return a value in the recursion to this execution context's caller (a pair of values in this case).                                                                                                   |Concept: 1) use post-order traversal to find the average of the values of each node's left and right subtrees and compare it against the current node's value.                                                                                                                              |
|Tree / Binary Tree / Depth-First Search / Recursion                              |H      |[](https://leetcode.com/problems/binary-tree-maximum-path-sum/)[124](https://leetcode.com/problems/binary-tree-maximum-path-sum/)                                                          |[](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC124-binaryTreeMaximumPathSum.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC124-binaryTreeMaximumPathSum.py)                                                    |Binary Tree Maximum Path Sum                             |This is considered a postorder traversal because we traverse the left subtree, then right subtree, then we process the current. When returning in the DFS, we get max between cur, cur + left and cur + right because it's more explicit so it's easier to trace and understand, but the singular cur.val is not needed since negatives are changed to 0. If the tree is height-balanced, space complexity is O(logn) for the call stack.                                                                                                                                                                                                                                                                                                                                                                                                                                                           |Concept: 1) Use post-order traversal to find the maximum path sum that goes through every node and its subtrees.                                                                                                                                                                            |
|Level-order Traversal                                                            |:lemon:|                                                                                                                                                                                           |                                                                                                                                                                                                                                                      |                                                         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |                                                                                                                                                                                                                                                                                            |
|Tree / Binary Tree / Breadth-First Search / Recursion                            |M      |[](https://leetcode.com/problems/binary-tree-level-order-traversal/)[102](https://leetcode.com/problems/binary-tree-level-order-traversal/)                                                |[](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC102-binaryTreeLevelOrderTraversal.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC102-binaryTreeLevelOrderTraversal.py)                                          |Binary Tree Level Order Traversal                        |This is a standard BFS traversal on a tree. If you are asked to do some type of processing of a tree structure level-wise, it will always be a BFS traversal. It is nearly identical in form to doing a BFS on a graph.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |Concept: Use level-order traversal to traverse a binary tree.                                                                                                                                                                                                                               |
|Tree / N-ary Tree / Breadth-First Search / Recursion                             |M      |[](https://leetcode.com/problems/n-ary-tree-level-order-traversal/description/)[429](https://leetcode.com/problems/n-ary-tree-level-order-traversal/description/)                          |[](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC429-n-aryTreeLevelOrderTraversal.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC429-n-aryTreeLevelOrderTraversal.py)                                            |N-ary Tree Level Order Traversal                         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |Concept: Use level-order traversal to traverse an n-ary tree.                                                                                                                                                                                                                               |
|Tree / Binary Tree / Breadth-First Search / Recursion                            |M      |[](https://leetcode.com/problems/maximum-level-sum-of-a-binary-tree/)[1161](https://leetcode.com/problems/maximum-level-sum-of-a-binary-tree/)                                             |[](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC1161-maximumLevelSumOfBinaryTree.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC1161-maximumLevelSumOfBinaryTree.py)                                            |Maximum Level Sum of a Binary Tree                       |Make sure the level_sum > max_level_sum check is > not >= because we want the minimum level. If we update based on if they are equal too, we are then taking the maximum level.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |Concept: Use level-order traversal to traverse a binary tree, tracking the sum of all node values of each level.                                                                                                                                                                            |
|Vertical-order Traversal                                                         |:lemon:|                                                                                                                                                                                           |                                                                                                                                                                                                                                                      |                                                         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |                                                                                                                                                                                                                                                                                            |
|Tree / Binary Tree / Hash Map / Depth-First Search / Recursion                   |H      |[](https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/)[987](https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/)                                |[](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC987-verticalOrderTraversalOfABinaryTree.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC987-verticalOrderTraversalOfABinaryTree.py)                              |Vertical Order Traversal of a Binary Tree                |The time complexity comes from the sorting of the columns and the rows when creating the result array that we return. A difficult part of the problem (at least for me) is traversing the dictionary to get the result. Not often are you required to sort keys in a dictionary, so not having this knowledge might push you to a different approach entirely which might be harder to implement. This is why knowing the data structures in your language and how to manipulate them is very important.                                                                                                                                                                                                                                                                                                                                                                                            |Concept: 1) Get the vertical ordering of a binary tree by using a column-to-row mapping. Similar to LC 314.                                                                                                                                                                                 |
|Binary Search Tree                                                               |:lemon:|                                                                                                                                                                                           |                                                                                                                                                                                                                                                      |                                                         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |                                                                                                                                                                                                                                                                                            |
|Tree / Binary Search Tree / Depth-First Search / Recursion                       |E      |[](https://leetcode.com/problems/search-in-a-binary-search-tree/)[700](https://leetcode.com/problems/search-in-a-binary-search-tree/)                                                      |[](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC700-searchInABinarySearchTree.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC700-searchInABinarySearchTree.py)                                                  |Search in a Binary Search Tree                           |For time complexity, it is O(log(N)) if the tree is height-balanced and O(N) if it is not. Using the iterative traversal uses O(1) space because we do not need stack space for the function calls. As for recursion, the worst-case would be if the value we are looking for is a leaf node. No matter what, this scenario would yield a space complexity of O(H) due to the stack frames needed for each function call.                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |Concept: 1) Use binary search to find a target value in a binary search tree.                                                                                                                                                                                                               |
|Tree / Binary Search Tree / Depth-First Search / Recursion                       |M      |[](https://leetcode.com/problems/validate-binary-search-tree/)[98](https://leetcode.com/problems/validate-binary-search-tree/)                                                             |[](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC98-validateBinarySearchTree.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC98-validateBinarySearchTree.py)                                                      |Validate Binary Search Tree                              |All we have to do is keep a running minimum and maximum bound for each recursive call in the DFS as parameters, update them accordingly and check cur.val against them. To evaluate the boolean value of all subtrees, we need evaluate the left and right subtrees at each root. This is a very common subpattern of preorder traversal where we have a base case that returns a result and another case that acts as the processing part for the preorder traversal before dfs on left and right are called. Then we return left AND right, so True is only returned if all subtrees evaluate to True.                                                                                                                                                                                                                                                                                            |Concept: 1) Use preorder traversal to check if each node in a binary search tree is valid. 2) Use boolean evaluation for the return statement.                                                                                                                                              |
|Tree / Binary Search Tree / Depth-First Search / Recursion                       |M      |[](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/)[235](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/)                      |[](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC235-lowestCommonAncestorOfABinarySearchTree.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC235-lowestCommonAncestorOfABinarySearchTree.py)                      |Lowest Common Ancestor of a Binary Search Tree           |Different from finding LCA of a tree that does not have the BST property because we know the upper bound of values in the left subtree and the lower bound of values in the right subtree at each root node of each subtree.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |Concept: 1) Use the BST property to check what subtree a target value is in relation to the current value. 2) Lowest common ancestor.                                                                                                                                                       |
|Tree / Binary Search Tree / Depth-First Search / Recursion                       |M      |[](https://leetcode.com/problems/insert-into-a-binary-search-tree/)[701](https://leetcode.com/problems/insert-into-a-binary-search-tree/)                                                  |[](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC701-insertIntoABinarySearchTree.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC701-insertIntoABinarySearchTree.py)                                              |Insert into a Binary Search Tree                         |The idea for this algorithm is to greedily search for an insert position at a position at the bottom of the tree that will make it a leaf. For the recursive function, there is no need to return anything because we are just updating a reference. For the iterative approach, we can iterate while True because we are guaranteed to reach a leaf node. Both approaches greedily converge to an insert position and look ahead to see if the reference in the correct direction is None.                                                                                                                                                                                                                                                                                                                                                                                                         |Concept: 1) Use binary search to search for an insert position and insert a new node with a given value.                                                                                                                                                                                    |
|Tree / Binary Search Tree / Depth-First Search / Recursion                       |M      |[](https://leetcode.com/problems/convert-bst-to-greater-tree/)[538](https://leetcode.com/problems/convert-bst-to-greater-tree/)                                                            |[](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC538-convertBSTToGreaterTree.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC538-convertBSTToGreaterTree.py)                                                      |Convert BST to Greater Tree                              |This traversal is considered to be reverse inorder traversal. Inorder traversal is Left -> Root -> Right. Reverse inorder is Right -> Root -> Left. To explain why inorder and why reverse: The reason we do inorder traversal because inorder traversal of a BST processes each node in order from smallest to largest. (Keep in mind this is for a BST specifically). And the reason we do it in reverse order is because we want to process the nodes in order from largest to smallest according to the problem statement.                                                                                                                                                                                                                                                                                                                                                                      |Concept: 1) Use reverse in-order traversal to add the postfix sum of the sorted values to each node.                                                                                                                                                                                        |
|Construct Tree                                                                   |:lemon:|                                                                                                                                                                                           |                                                                                                                                                                                                                                                      |                                                         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |                                                                                                                                                                                                                                                                                            |
|Array / Tree / Binary Tree / Depth-First Search / Recursion                      |E      |[](https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/)[108](https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/)                              |[](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC108-convertSortedArrayToBST.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC108-convertSortedArrayToBST.py)                                                      |Convert Sorted Array to BST                              |We have to use the sorted property of the array along with the relationship between values in a binary search tree to solve the problem. For the root of every subtree in a binary search tree, all of the values in the left subtree are less than the root, while all of the values in the right subtree are greater than the root. Since we want a height-balanced tree, we want the left and right subtrees to be of similar height. So we pick the root to be the middle of the array. Then we set the left child and right child of this root as the middle of the left subarray and right subarray respectively. We will do this recursively. The base case is when nums is empty, we return None.                                                                                                                                                                                           |Concept: 1) Convert a sorted array to a binary search tree.                                                                                                                                                                                                                                 |
|Array / Tree / Binary Tree / Depth-First Search / Recursion                      |M      |[](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)[105](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)|[](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC105-constructBinaryTreeFromPreorderAndInorderTraversal.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC105-constructBinaryTreeFromPreorderAndInorderTraversal.py)|Construct Binary Tree from Preorder and Inorder Traversal|More explanation: The global 'preorder_index' is helpful because the preorder value is always the next value in the preorder array after a root is created. Root.left and root.right is fairly trivial now since we are only changing the bound respective to its side and we do not include the root value in each bound.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |Concept: 1) Convert a pre-order array and an in-order array into a binary tree.                                                                                                                                                                                                             |
|Tree / Binary Tree / Depth-First Search / Recursion                              |H      |[](https://leetcode.com/problems/serialize-and-deserialize-binary-tree/)[297](https://leetcode.com/problems/serialize-and-deserialize-binary-tree/)                                        |[](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC297-serializeAndDeserializeBinaryTree.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC297-serializeAndDeserializeBinaryTree.py)                                  |Serialize and Deserialize Binary Tree                    |There are two main ways these functions can be implemented. With DFS and with BFS. I prefer BFS because I think it is way easier to visualize the construction of a tree through BFS. Serialize matches the type of BFS you normally see because it is being done on a tree structure, whereas deserialize is doing BFS on a string. In deserialize it really is just a matter of understanding how to traverse the array to create the nodes and update the references to left and right of each root node. I strongly recommend watching Striver's video (the first 7 minutes) to get a good visualization on how this translation between a tree structure and string is done.                                                                                                                                                                                                                   |Concept: 1) Serialize and deserialize a binary tree.                                                                                                                                                                                                                                        |
|Binary Tree Indices                                                              |:lemon:|                                                                                                                                                                                           |                                                                                                                                                                                                                                                      |                                                         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |                                                                                                                                                                                                                                                                                            |
|Tree / Binary Tree / Hash Set / Depth-First Search / Recursion                   |M      |[](https://leetcode.com/problems/find-elements-in-a-contaminated-binary-tree/description/)[1261](https://leetcode.com/problems/find-elements-in-a-contaminated-binary-tree/description/)   |[](https://github.com/BrandonKenter/Solutions/blob/main/Hash%20Map/LC1261-findElementsInAContaminatedBinaryTree.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Hash%20Map/LC1261-findElementsInAContaminatedBinaryTree.py)            |Find Elements in a Contaminated Binary Tree              |This is similar to problems where you need the index of a node in a tree. One of these other problems is LC 662 - "Maximum Width of Binary Tree". So once we notice that the values of each node in this problem are actually the indices, you just need to know the formulas for calculating them and then this problem becuase fairly trivial. The formulas for each index: Left child = cur val \* 2 + 1. Right child = cur val \* 2 + 2. These indices can be found either with BFS or DFS. Both implementations use a "self.values" set to store visited indices of nodes, which is important to make the find() function an O(1) lookup.                                                                                                                                                                                                                                                      |Concept: 1) Binary tree indices.                                                                                                                                                                                                                                                            |
|Tree / Binary Tree / Depth-First Search / Recursion                              |M      |[](https://leetcode.com/problems/check-completeness-of-a-binary-tree/description/)[958](https://leetcode.com/problems/check-completeness-of-a-binary-tree/description/)                    |[](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC958-checkCompletenessOfABinaryTree.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC958-checkCompletenessOfABinaryTree.py)                                        |Check Completeness of a Binary Tree                      |A helpful trick you can use with binary trees is to calculate the index of each node from top to bottom and left to right. To calculate the node's index in the tree, start the root node at index 0. Then when we call dfs on the children, the left child's index is 2\*i+1, while the right child's index is 2\*i+2. We can use these indices to check if the last node we saw on the last level is equal to the number of nodes seen - 1. To have access to the last node's index in the last level of the tree, update it when we are at the max height/depth of the tree so far. Since dfs traverses the tree left to right, this is guaranteed to be the rightmost node in the last level of the tree.                                                                                                                                                                                       |Concept: 1) Binary tree indices. 2) Complete binary tree definition.                                                                                                                                                                                                                        |
|Build Graph                                                                      |:lemon:|                                                                                                                                                                                           |                                                                                                                                                                                                                                                      |                                                         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |                                                                                                                                                                                                                                                                                            |
|Tree / Binary Tree / Graph / Breadth-First Search                                |M      |[](https://leetcode.com/problems/all-nodes-distance-k-in-binary-tree/)[863](https://leetcode.com/problems/all-nodes-distance-k-in-binary-tree/)                                            |[](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC863-allNodesDistanceKInBinaryTree.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC863-allNodesDistanceKInBinaryTree.py)                                          |All Nodes Distance K in Binary Tree                      |We need a visited hash set in the BFS because we have undirected edges in the new adjacency list. This is an important distinction between trees (no cycles) and undirected graphs (cycles). For populating the adjacency list, DFS is simpler and a better average time complexity (if tree is height-balanced because space complexity is O(log(N)) for the call stack instead of O(N) that the queue in BFS uses). For creating adj list with DFS, use cur and parent parameters and add undirected edge to adjacency list if cur and parent are not None. One thing to think about is how this way avoids duplicate edges. Imagine if you made an entry for left and right child at each DFS call.                                                                                                                                                                                              |Concept: 1) Convert tree to graph. 2) Use breadth-first search to find distance to target value.                                                                                                                                                                                            |
|Tree / N-ary Tree / Graph / Depth-First Search / Breadth-First Search / Recursion|M      |[](https://leetcode.com/problems/reachable-nodes-with-restrictions/description/)[2368](https://leetcode.com/problems/reachable-nodes-with-restrictions/description/)                       |[](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC2368-reachableNodesWithRestrictions.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC2368-reachableNodesWithRestrictions.py)                                      |Reachable Nodes With Restrictions                        |This is a standard DFS/BFS problem with a few extra complexities. The first complexity is checking if a node is restricted or not so we avoid going down this path. To do this efficiently, cast restricted to a set so we can do O(1) lookups for node values. The second complexity is the edges being undirected. Most tree problems provide a tree data structure with ListNodes that have directed edges (left and right typically), so you can only traverse the tree in one direction. But for this problem, we are only provided edges, and these edges are undirected. So when we start from 0 and go down the tree, we have to make sure we aren't going back up the tree and recounting nodes/going into an infinite loop. To avoid this, just use a prev reference for the parent node and make sure the neighbor node we are about to call DFS on isn't the parent of the current node.|Concept: 1) Convert tree to graph. 2) Using prev to avoid traversing already traversed nodes, while also avoiding traversing nodes that are restricted. 3) Know how to do this for DFS and BFS (use prev parameter in DFS method signature and use tuples of (cur, prev) as nodes in queue).|
|Node Relationships                                                               |:lemon:|                                                                                                                                                                                           |                                                                                                                                                                                                                                                      |                                                         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |                                                                                                                                                                                                                                                                                            |
|Tree / Binary Tree / Breadth-First Search / Recursion                            |E      |[](https://leetcode.com/problems/cousins-in-binary-tree/description/)[993](https://leetcode.com/problems/cousins-in-binary-tree/description/)                                              |                                                                                                                                                                                                                                                      |Cousins in Binary Tree                                   |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |Concept: 1) Cousins in a binary tree.                                                                                                                                                                                                                                                       |
|Tree / Binary Tree / Breadth-First Search / Recursion                            |M      |[](https://leetcode.com/problems/sum-of-nodes-with-even-valued-grandparent/)[1315](https://leetcode.com/problems/sum-of-nodes-with-even-valued-grandparent/)                               |[](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC1315-sumOfNodesWithEven-ValuedGrandparent.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC1315-sumOfNodesWithEven-ValuedGrandparent.py)                          |Sum of Nodes with Even-Valued Grandparent                |This implementation is an improvement on the slightly naÃ¯ve approach of storing a path array that holds state that describes each node as either even or odd. But this adds an extra O(H) space complexity. For a constant O(1) space complexity, we keep two variables 'parent' and 'grand' to keep track of the even/odd bool for each node's ancestors. A mistake I initially made is trying to update grand to parent before checking 'if grand' in the recursive procedure. We want update grand after 'if grand' because the code assumes parent and grand are already updated before this check.                                                                                                                                                                                                                                                                                             |Concept: 1) Grandparents in a binary tree.                                                                                                                                                                                                                                                  |

## Backtracking

|Permutations                                                             |:lemon:|                                                                                                                                                                                                                |                                                                                                                                                                                                                                                                |                                                       |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |                                                                                                                                                                                                                                                                |
|-------------------------------------------------------------------------|-------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|Array / Depth-First Search / Backtracking / Recursion                    |M      |[](https://leetcode.com/problems/permutations/)[46](https://leetcode.com/problems/permutations/)                                                                                                                |[](https://github.com/BrandonKenter/Solutions/blob/main/Backtracking/LC46-permutations.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Backtracking/LC46-permutations.py)                                                                        |Permutations                                           |Order matters with permutations, whereas order does NOT matter with combinations. This is significant because we then have to make sure every ordering is expressed. To do so, we use an array that encodes whether an element in the input collection has been used or not. The for loop inside of each recursive call tries every position for every element.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |Concept: 1) Generate a list of all the permutations of a given list of numbers.                                                                                                                                                                                 |
|Depth-First Search / Backtracking / Recursion                            |M      |[](https://leetcode.com/problems/beautiful-arrangement/)[526](https://leetcode.com/problems/beautiful-arrangement/)                                                                                             |[](https://github.com/BrandonKenter/Solutions/blob/main/Backtracking/LC526-beautifulArrangement.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Backtracking/LC526-beautifulArrangement.py)                                                      |Beautiful Arrangement                                  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |Concept: 1) Count all of the unique permutations that can be made in a range of numbers that follows a constraint. 2) Implicit collection of elements.                                                                                                          |
|String/ Depth-First Search / Backtracking / Recursion                    |M      |[](https://leetcode.com/problems/letter-case-permutation/)[784](https://leetcode.com/problems/letter-case-permutation/)                                                                                         |[](https://github.com/BrandonKenter/Solutions/blob/main/Backtracking/LC784-letterCasePermutation.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Backtracking/LC784-letterCasePermutation.py)                                                    |Letter Case Permutation                                |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |Concept: 1) Generate all permuations of letter cases in a string. 2) Append number or recurse on choice to use lower case and recurse on choice to use upper case.                                                                                              |
|Matrix                                                                   |:lemon:|                                                                                                                                                                                                                |                                                                                                                                                                                                                                                                |                                                       |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |                                                                                                                                                                                                                                                                |
|Matrix / Hash Set / Depth-First Search / Backtracking / Recursion        |H      |[](https://leetcode.com/problems/n-queens/)[51](https://leetcode.com/problems/n-queens/)                                                                                                                        |[](https://github.com/BrandonKenter/Solutions/blob/main/Backtracking/LC51-N-Queens.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Backtracking/LC51-N-Queens.py)                                                                                |N-Queens                                               |Base case: if r == n, append the board to the result array. Choice: Iterate for col in the range of the number of rows. If the column passes the valid state check, add it to the state. Otherwise, skip this entire if block (prune res of decision tree). Recursive procedure: backtrack(r + 1).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |Concept: 1) Generate all permutations of element placements in a 2D matrix that adheres to the constraints.                                                                                                                                                     |
|Backtracking                                                             |H      |[](https://leetcode.com/problems/sudoku-solver/)[37](https://leetcode.com/problems/sudoku-solver/)                                                                                                              |[](https://github.com/BrandonKenter/Solutions/blob/main/Backtracking/LC37-sudokuSolver.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Backtracking/LC37-sudokuSolver.py)                                                                        |Sudoku Solver                                          |Base case: if r == 9, return True. Constraints: Value in current cell must be unique for its respective row/col/square set and be in the range [1, 9]. Choice: If cell == '.', choose between the values [1, 9] to put in this cell. Pay attention to where the valid state checking is at. For this problem, it is inside the for loop. For word search, it is at the base case. We put it inside the for loop because it is the necessary placement for the execution flow. Why? Because the beginning of the for loop is the entry point for the changing state. This is the first part of the algorithm that sees this new value. The discrepency comes from carrying the state change as a method parameter vs generating it in a for loop. Check if choice meets constraints BEFORE recursing because you can't backtrack from a choice where you add the same number to a set since the set only encodes 1 number and cleaning up this decision by removing it wouldn't work as intended.(Hash map is a workaround, but general idea is to consider checking constraints before recursing).|Concept: 1) Generate a permutations of elements in a 2D matrix that adheres to the constraints. 2) If using a set to track choices, check constraint before making the choice since you can't backtrack from the choice of adding a duplicate number to the set.|
|Combinations                                                             |:lemon:|                                                                                                                                                                                                                |                                                                                                                                                                                                                                                                |                                                       |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |                                                                                                                                                                                                                                                                |
|String / Hash Map / Depth-First Search / Backtracking / Recursion        |M      |[](https://leetcode.com/problems/letter-combinations-of-a-phone-number/)[17](https://leetcode.com/problems/letter-combinations-of-a-phone-number/)                                                              |[](https://github.com/BrandonKenter/Solutions/blob/main/Backtracking/LC17-letterCombinationsOfAPhoneNumber.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Backtracking/LC17-letterCombinationsOfAPhoneNumber.py)                                |Letter Combinations of Phone #                         |We are asked to get every possible letter combination given digits. Since there is no way to avoid enumerating every possible combination, we can think of this problem as exploring all possible states, which tells us we need to use recursion. Our state is described as the index we are at in the digits string as well as the current combination we have built up. Reaching i == len(digits) signifies we have reached a solution state. The index is the only part of our state that can break the problem constraints (by going beyond the last digit in digits). So we don't need any other valid state checking beyond the base case for appending to res. As for our choices, the for loop handles this. For the backtrack, we just need to pop from combo.                                                                                                                                                                                                                                                                                                                          |Concept: 1) Generate all combinations of letters that can be produced from a phone number. 2) Use a hash map to map numbers to letters so each number's possible choices can be iterated over.                                                                  |
|Array / Depth-First Search / Backtracking / Recursion                    |M      |[](https://leetcode.com/problems/combinations/)[77](https://leetcode.com/problems/combinations/)                                                                                                                |[](https://github.com/BrandonKenter/Solutions/blob/main/Backtracking/LC77-combinations.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Backtracking/LC77-combinations.py)                                                                        |Combinations                                           |This is similar to LC 78 - "Subsets" except we want combinations of size k and in the range [1, n].                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |Concept: 1) Generate all combinations with the constraints of combination size and numbers within a range.                                                                                                                                                      |
|Array / Depth-First Search / Backtracking / Recursion                    |M      |[](https://leetcode.com/problems/combination-sum/)[39](https://leetcode.com/problems/combination-sum/)                                                                                                          |[](https://github.com/BrandonKenter/Solutions/blob/main/Backtracking/LC39-combinationSum.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Backtracking/LC39-combinationSum.py)                                                                    |Combination Sum                                        |Our time complexity O(2^N\*N) because we are bounded by N instead of T since we can pick at most N elements if we have an element equal to 1 in the input candidates. The extra N is for copying the combination list we are building up to add it to the output list.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |Concept: 1) Generate all combinations with the constraints of a target combination sum and possible choices being a list of candidates.                                                                                                                         |
|Array / String / Hash Map / Depth-First Search / Backtracking / Recursion|H      |[](https://leetcode.com/problems/maximum-score-words-formed-by-letters/description/)[1255](https://leetcode.com/problems/maximum-score-words-formed-by-letters/description/)                                    |                                                                                                                                                                                                                                                                |Maximum Score Words Formed by Letters                  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |Concept: 1) Generate a combination of words that has a maximum score. 2) Track and backtrack choices using a count hash map for each used character.                                                                                                            |
|Array / Depth-First Search / Backtracking / Recursion                    |M      |[](https://leetcode.com/problems/fair-distribution-of-cookies/)[2305](https://leetcode.com/problems/fair-distribution-of-cookies/)                                                                              |                                                                                                                                                                                                                                                                |Fair Distribution of Cookies                           |Each choice has the potential to put into k buckets. The reason we can't do partition backtracking is because the partitions don't have to be in order. So we instead opt to iterate over the buckets (children) to make a choice to put the current in one of the k buckets.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |Concept: 1) Bucket backtracking.                                                                                                                                                                                                                                |
|Array / Depth-First Search / Backtracking / Recursion                    |M      |[](https://leetcode.com/problems/matchsticks-to-square/)[473](https://leetcode.com/problems/matchsticks-to-square/)                                                                                             |[](https://github.com/BrandonKenter/Solutions/blob/main/Backtracking/LC473-matchsticksToSquare.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Backtracking/LC473-matchsticksToSquare.py)                                                        |Matchsticks to Square                                  |In problems like Sudoku Solver, we are recursing through the input collection (board) and iterating through the choice spcae (numbers 1-10). For this problem, it is slightly different. We are recursing through the input collection (matchsticks array) and iterating through the choice space (position in the state collection). The key thing to understand for this problem is we are essentially trying to find the correct combination of matchsticks for each side (bucket) of the square.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |Concept: 1) Determine if an array partitioned into buckets where each bucket adheres to a constraint.                                                                                                                                                           |
|Partition Sequence                                                       |:lemon:|                                                                                                                                                                                                                |                                                                                                                                                                                                                                                                |                                                       |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |                                                                                                                                                                                                                                                                |
|String / Hash Set / Depth-First Search / Backtracking / Recursion        |M      |[](https://leetcode.com/problems/split-a-string-into-the-max-number-of-unique-substrings/description/)[1593](https://leetcode.com/problems/split-a-string-into-the-max-number-of-unique-substrings/description/)|[](https://github.com/BrandonKenter/Solutions/blob/main/Backtracking/LC1593-splitAStringIntoTheMaxNumberOfUniqueSubstrings.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Backtracking/LC1593-splitAStringIntoTheMaxNumberOfUniqueSubstrings.py)|Split a String Into the Max Number of Unique Substrings|                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |Concept: 1) Generate all partitions of a string that adhere to constraints.                                                                                                                                                                                     |
|String / Depth-First Search / Backtracking / Recursion                   |M      |[](https://leetcode.com/problems/palindrome-partitioning/)[131](https://leetcode.com/problems/palindrome-partitioning/)                                                                                         |[](https://github.com/BrandonKenter/Solutions/blob/main/Backtracking/LC131-palindromePartitioning.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Backtracking/LC131-palindromePartitioning.py)                                                  |Palindrome Partitioning                                |This is similar to Restore IP Addresses in that this is a substring backtracking problem. We want to partition the array into different substrings that adhere to the constraints.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |Concept: 1) Generate all partitions of a string that adhere to constraints. 2) Check if a substring is a palindrome.                                                                                                                                            |
|String / Hash Set / Depth-First Search / Backtracking / Recursion        |H      |[](https://leetcode.com/problems/word-break-ii/description/)[140](https://leetcode.com/problems/word-break-ii/description/)                                                                                     |[](https://github.com/BrandonKenter/Solutions/blob/main/Backtracking/LC140-wordBreakII.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Backtracking/LC140-wordBreakII.py)                                                                        |Word Break II                                          |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |Concept: 1) Generate all partitions of a string that adhere to constraints.                                                                                                                                                                                     |
|Generate Sequence                                                        |:lemon:|                                                                                                                                                                                                                |                                                                                                                                                                                                                                                                |                                                       |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |                                                                                                                                                                                                                                                                |
|Depth-First Search / Backtracking / Recursion                            |M      |[](https://leetcode.com/problems/numbers-with-same-consecutive-differences/description/)[967](https://leetcode.com/problems/numbers-with-same-consecutive-differences/description/)                             |[](https://github.com/BrandonKenter/Solutions/blob/main/Backtracking/LC967-numbersWithSameConsecutiveDifferences.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Backtracking/LC967-numbersWithSameConsecutiveDifferences.py)                    |Numbers With Same Consecutive Differences              |There are a lot of people who classify their solutions as DFS or use BFS of some kind, but this problem is designed for backtracking (yes, DFS and backtracking are often used interchangeably for problems that explore all possibilities). I think my solution is by far the easiest to use for most other backtracking problems since it fits my backtracking template.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |Concept: 1) Generate all sequences that adhere to constraints.                                                                                                                                                                                                  |
|Subsets                                                                  |:lemon:|                                                                                                                                                                                                                |                                                                                                                                                                                                                                                                |                                                       |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |                                                                                                                                                                                                                                                                |
|Array / Depth-First Search / Backtracking / Recursion                    |M      |[](https://leetcode.com/problems/subsets/)[78](https://leetcode.com/problems/subsets/)                                                                                                                          |[](https://github.com/BrandonKenter/Solutions/blob/main/Backtracking/LC78-subsets.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Backtracking/LC78-subsets.py)                                                                                  |Subsets                                                |For subsets, order does not matter. So [1, 2] is considered to be the same as [2, 1]. This is considered to be a problem that a brute-force approach cannot be avoided because we have to generate all subsets. There is no way to shortcut the generation of 2^N subsets. Why is there 2^N subsets for a list of unique elements? Because at every index, we can choose to 1) include the element or 2) skip the element. This is two choices at each index. So 2^N possible choices. If the output array is considered as a part of the space comlexity, it is O(2^N^2).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |Concept: 1) Generate all subsets of a given list of numbers.                                                                                                                                                                                                    |
|Array / Depth-First Search / Backtracking / Recursion                    |M      |[](https://leetcode.com/problems/subsets-ii/)[90](https://leetcode.com/problems/subsets-ii/)                                                                                                                    |[](https://github.com/BrandonKenter/Solutions/blob/main/Backtracking/LC90-subsetsII.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Backtracking/LC90-subsetsII.py)                                                                              |Subsets II                                             |This is similar to LC 78 - "Subsets" with one difference: there can be duplicate values in the input array nums. So it isn't sufficient to just do the same approach as in LC 78. If we have an input array of [1, 2, 2], the previous approach will add duplicate subsets such as [1, 2] and [1, 2] because we can pick either of the two 2's. To avoid duplicates, we must adjust our pick/not pick logic. If we pick an element, we can pick that element's value again in the future for this path. But if we skip it, we must skip all future elements equal to this value. To help with this, we sort the input array nums. Order doesn't matter. Pick or don't pick. If not picking element, skip all instances of this element. Sort at beginning.                                                                                                                                                                                                                                                                                                                                        |Concept: 1) Generate all unique subsets of a given list of numbers that may contain duplicates. 2) Presorting to make a decision based on adjacent numbers in sorted order.                                                                                     |
|Search                                                                   |:lemon:|                                                                                                                                                                                                                |                                                                                                                                                                                                                                                                |                                                       |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |                                                                                                                                                                                                                                                                |
|Matrix / Hash Set / Depth-First Search / Backtracking / Recursion        |M      |[](https://leetcode.com/problems/word-search/)[79](https://leetcode.com/problems/word-search/)                                                                                                                  |[](https://github.com/BrandonKenter/Solutions/blob/main/Backtracking/LC79-wordSearch.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Backtracking/LC79-wordSearch.py)                                                                            |Word Search                                            |Base cases: If we reach end of word or the current (r, c) cell is not valid. Constraints: Char in the current cell must match the current index of the word. Choice: Go up, down, left or right from the current cell if the current cell's char matches the current index of the word. For the time complexity: it is 3^L where L is the length of the word because we won't recurse on a visited cell, so that leaves us with at most 3 options in direciton.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |Concept: 1) Search for a sequence of elements in a 2D matrix.                                                                                                                                                                                                   |
|Matrix / Hash Set / Depth-First Search / Backtracking / Recursion        |H      |[](https://leetcode.com/problems/unique-paths-iii/description/)[980](https://leetcode.com/problems/unique-paths-iii/description/)                                                                               |Code                                                                                                                                                                                                                                                            |Unique Paths III                                       |The is a "number of ways" recursion subpattern. For the base cases, if the condition is not met, we return 0. If it is met, we return 1. Then for the recursive procedure we have the paths variable starting at 0 and add to it the return value of each dfs call. Make sure we add to cur_vis before calling dfs on this cell, then remove from cur_vis when the calls return and return the paths array to its parent calls.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |Concept: 1) Number of ways to arrive at a destination with up, down, left and right moves. 2) Matrix search backtracking.                                                                                                                                       |

## Binary Search

|Binary Search                                |       |                                                                                                                                                                                                              |                                                                                                                                                                                                                                                                  |                                                       |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |                                                                                                                                                                                                                 |
|---------------------------------------------|-------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|Element Search                               |:lemon:|                                                                                                                                                                                                              |                                                                                                                                                                                                                                                                  |                                                       |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |                                                                                                                                                                                                                 |
|Array / Binary Search / Two Pointers         |E      |[](https://leetcode.com/problems/binary-search/)[704](https://leetcode.com/problems/binary-search/)                                                                                                           |[](https://github.com/BrandonKenter/Solutions/blob/main/Binary%20Search/LC704-binarySearch.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Binary%20Search/LC704-binarySearch.py)                                                                  |Binary Search                                          |This is the target subpattern because we are looking for a specific element to see if it exists in the array or not. So we can do a standard binary search while left <= right and updating the search space based on what the element's value is at our pivot index mid in comparison to our target value.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |Concept: 1) Use binary search to find an explicit value in a sorted collection of elements.                                                                                                                      |
|Binary Search / Two Pointers                 |E      |[](https://leetcode.com/problems/guess-number-higher-or-lower/)[374](https://leetcode.com/problems/guess-number-higher-or-lower/)                                                                             |[](https://github.com/BrandonKenter/Solutions/blob/main/Binary%20Search/LC374-guessNumberHigherOrLower.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Binary%20Search/LC374-guessNumberHigherOrLower.py)                                          |Guess Number Higher or Lower                           |This is a standard binary search for a target number with the slight added complexity of using an API to determine the mid's relation to the target. The Target/Contains subpattern either finds the target and returns or updates the search space based on the target.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |Concept: 1) Use binary search to find an explicit value in a sorted implicit collection of elements.                                                                                                             |
|Matrix / Binary Search / Two Pointers        |M      |[](https://leetcode.com/problems/search-a-2d-matrix/)[74](https://leetcode.com/problems/search-a-2d-matrix/)                                                                                                  |[](https://github.com/BrandonKenter/Solutions/blob/main/Binary%20Search/LC704-binarySearch.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Binary%20Search/LC704-binarySearch.py)                                                                  |Search a 2D Matrix                                     |This is a target subpattern because we are looking for a specific element to see if it exists in the 2D matrix or not. We first look for the row using top and bottom pointers (break when found since we can't return early unless this is in its own function). To get the row we can do the mid calculation again, or we can store the mid in a variable outside of the while loop. Then from the second binary search on the row, we use left and right pointers to get the column and return True if the element is found or False if the while loop terminates without finding the element. We don't need to have an overflow-friendly mid calculation because of the constraints of m and n in this problem, but this should always be discussed in an interview.                                                                                                                                                                      |Concept: 1) Use binary search to find an explicit value in a sorted collection of elements in a 2D matrix.                                                                                                       |
|Array / Binary Search / Two Pointers         |M      |[](https://leetcode.com/problems/search-in-rotated-sorted-array/)[33](https://leetcode.com/problems/search-in-rotated-sorted-array/)                                                                          |[](https://github.com/BrandonKenter/Solutions/blob/main/Binary%20Search/LC33-searchInRotatedSortedArray.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Binary%20Search/LC33-searchInRotatedSortedArray.py)                                        |Search in Rotated Sorted Array                         |The first thing that should come to mind when hearing search in a sorted array is binary search. But, we have added complexity with the array being rotated. The binary search can be augmented by first checking which sorted portion of the array our pivot value 'mid' is in. To do this, we do the 'if nums[left] <= nums[mid]' check. Then we check target against nums[mid] and the left/right boundary depending on what sorted portion we determined we were in at the last step. If the left pointer crosses the right pointer without us finding the target, we can return -1. This is the same as returning T/F if the number can be found or not, which is why this is considered to be the "contains" subpattern for binary search.                                                                                                                                                                                              |Concept: 1) Use binary search to find an explicit value in a sorted collection of elements that is rotated.                                                                                                      |
|Array / Binary Search / Two Pointers         |M      |[](https://leetcode.com/problems/find-peak-element/)[162](https://leetcode.com/problems/find-peak-element/)                                                                                                   |[](https://github.com/BrandonKenter/Solutions/blob/main/Binary%20Search/LC162-findPeakElement.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Binary%20Search/LC162-findPeakElement.py)                                                            |Find Peak Element                                      |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |Concept: 1) Use binary search to find a value with a specific relation to its adjacent values.                                                                                                                   |
|Array / Binary Search / Two Pointers         |M      |[](https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/)[34](https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/)                        |[](https://github.com/BrandonKenter/Solutions/blob/main/Binary%20Search/LC34-findFirstAndLastPositionOfElementInSortedArray.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Binary%20Search/LC34-findFirstAndLastPositionOfElementInSortedArray.py)|Find First and Last Position of Element in Sorted Array|Both templates are appropriate for this problem, but the first template is a bit easier to implement because template 2 requires more edge case handling.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |Concept: Use binary search to find the leftmost and rightmost instances of a target value.                                                                                                                       |
|Condition Search                             |:lemon:|                                                                                                                                                                                                              |                                                                                                                                                                                                                                                                  |                                                       |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |                                                                                                                                                                                                                 |
|Array / Binary Search / Two Pointers         |E      |[](https://leetcode.com/problems/search-insert-position/)[35](https://leetcode.com/problems/search-insert-position/)                                                                                          |[](https://github.com/BrandonKenter/Solutions/blob/main/Binary%20Search/LC35-searchInsertPosition.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Binary%20Search/LC35-searchInsertPosition.py)                                                    |Search Insert Position                                 |Template 2: The True side starts at the first number that is greater than or equal to the target. The case where the target exists is obvious, but when the target doesn't exist, we want to insert it after the number below it and before the number higher than it. Since the insert position has to be AFTER the number lower than it, the case where nums[mid] > target, we use the right = mid statement.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |Concept: 1) Use binary search to find the insert position of an element.                                                                                                                                         |
|Array / Binary Search / Two Pointers         |E      |[](https://leetcode.com/problems/maximum-count-of-positive-integer-and-negative-integer/description/)[2529](https://leetcode.com/problems/maximum-count-of-positive-integer-and-negative-integer/description/)|                                                                                                                                                                                                                                                                  |Maximum Count of Positive Integer and Negative Integer |Make sure to start right index as len(nums) because there can be cases where the index that represents the start of the positive numbers doesn't exist, which would allow us to do len(nums) - right (which would be len(nums)) to calculate the number of positive numbres, which ends up being 0.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |Concept: 1) Use binaary search to find the ending position of the negative numbers and the starting position of the positive numbers.                                                                            |
|Array / Binary Search / Two Pointers / Prefix|E      |[](https://leetcode.com/problems/longest-subsequence-with-limited-sum/)[2389](https://leetcode.com/problems/longest-subsequence-with-limited-sum/)                                                            |[](https://github.com/BrandonKenter/Solutions/blob/main/Binary%20Search/LC2389-longestSubsequenceWithLimitedSum.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Binary%20Search/LC2389-longestSubsequenceWithLimitedSum.py)                        |Longest Subsequence With Limited Sum                   |We can sort the array and then we are able to greedily include elements in the sequence from left to right. This greedy approach guarantees the longest subsequence for the desired query sum because we are adding the least amount to the sum at each index starting from the left. It is the "less or equal" subpattern because we are updating our longest we have so far by changing the index if val < query. And in the case where val == query, we can break because it will be the longest subsequence.                                                                                                                                                                                                                                                                                                                                                                                                                              |Concept: 1) Use binary search with prefix sums to find the first value that satisfies a condition (first prefix sum that is greater than queries[i]).                                                            |
|Array / Binary Search / Two Pointers         |M      |[](https://leetcode.com/problems/peak-index-in-a-mountain-array/)[852](https://leetcode.com/problems/peak-index-in-a-mountain-array/)                                                                         |[](https://github.com/BrandonKenter/Solutions/blob/main/Binary%20Search/LC852-peakIndexInAMountainArray.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Binary%20Search/LC852-peakIndexInAMountainArray.py)                                        |Peak Index in a Mountain Array                         |To fit a binary search template, we can't use template 1 because there is no easy way to implement the logic where we make a decision to search to the left or right since we don't have a target value and the array isn't totally sorted. So we instead opt for template 2. With every problem in template 2, we force our thinking by starting on the right side being the True condition. The goal is to find the pair of values where two consecutive values go from increasing to decreasing. The middle value is the peak index. From the right, the True condition can be arr[mid] < arr[mid-1]. This means the final True will have arr[right] as arr[mid], which is the leftmost occurrence where arr[mid] < arr[mid-1].                                                                                                                                                                                                            |Concept: 1) Use binary search to find the first element that satisfies a condition in an explicit collection of elements. 2) Compare current value to value to its left.                                         |
|Array / Binary Search / Two Pointers         |M      |[](https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/description/)[1011](https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/description/)                              |[](https://github.com/BrandonKenter/Solutions/blob/main/Binary%20Search/LC1011-capacityToShipPackagesWithinDDays.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Binary%20Search/LC1011-capacityToShipPackagesWithinDDays.py)                      |Capacity To Ship Packages Within D Days                |This is like LC 875, Koko eating bananas problem. We are searching for the least value that satisfies a condition. It's a subset of binary search that is O(Nlog(N)) time complexity because we have to make a guess, do O(N) time computations, then decrease the search space by half. This is bisect left.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |Concept: 1) Use binary search to find the first element in an implicit collection of elements (weight capacity) that satisfies a constraint (number of days to ship all packages with "mid" weight is <= "days").|
|Array / Binary Search / Two Pointers         |M      |[](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/)[153](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/)                                                             |[](https://github.com/BrandonKenter/Solutions/blob/main/Binary%20Search/LC153-findMinimumInRotatedSortedArray.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Binary%20Search/LC153-findMinimumInRotatedSortedArray.py)                            |Find Minimum in Rotated Sorted Array                   |With rotated sorted array binary search, we have to identify if we are in the left sorted portion or right sorted portion at each iteration. Unlike LC 33 - "Search in a Rotated Sorted Array", this is the only thing we have to check in terms of adjusting our search space at each iteration. In LC 33 we also had to compare the target value against the number at mid and left, but in this problem we aren't looking for a target - just the minimum value. So it is sufficient to just check if nums[left] is less than or equal to nums[mid] to adjust our search space. However, there is one edge case that we have to consider. We can be in the right sorted portion where our left index holds the min value. In this case our nums[left] <= nums[mid] would incorrectly ignore it and update the search space to left = mid + 1. To avoid this, we set a check at the beginning of each iteration if nums[left] < nums[right].|Concept: 1) Use binary search to find the first element in a rotated sortedarray that is smaller or equal to the element to its right.                                                                           |
|Misc                                         |:lemon:|                                                                                                                                                                                                              |                                                                                                                                                                                                                                                                  |                                                       |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |                                                                                                                                                                                                                 |
|Array / Binary Search / Two Pointers         |H      |[](https://leetcode.com/problems/median-of-two-sorted-arrays/)[4](https://leetcode.com/problems/median-of-two-sorted-arrays/)                                                                                 |                                                                                                                                                                                                                                                                  |Median of Two Sorted Arrays                            |Things to know: median of even length array is middle two elements / 2, while median of odd length array is middle element.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |Concept: 1) Binary search two sorted collections of elements.                                                                                                                                                    |

## Heap

|Greedy                          |:lemon:|                                                                                                                                                                                                    |                                                                                                                                                                                                                                      |                                                 |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |                                                                                                                                                                                                                                                                                                                                                                                               |
|--------------------------------|-------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|Array / Heap / Hash Map / Greedy|M      |[](https://leetcode.com/problems/distant-barcodes/description/)[1054](https://leetcode.com/problems/distant-barcodes/description/)                                                                  |                                                                                                                                                                                                                                      |Distant Barcodes                                 |Very similar to LC 767: Reorganize String.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |Concept: 1) Use max heap to get element with maximum frequency element where the element counts are dynamically changing. 2) Get max frequency element at each step to minimize chance of needing to use same element twice in a row in the future. 3) Pop from heap twice if the current maximum frequency element is equal to the previous selected element to avoid equal adjacent elements.|
|Array / Heap / Greedy           |M      |[](https://leetcode.com/problems/minimum-operations-to-halve-array-sum/description/)[2208](https://leetcode.com/problems/minimum-operations-to-halve-array-sum/description/)                        |[](https://github.com/BrandonKenter/Solutions/blob/main/Heap/LC2208-minimumOperationsToHalveArraySum.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Heap/LC2208-minimumOperationsToHalveArraySum.py)                  |Minimum Operations to Halve Array Sum            |Intuitively it makes sense that if we want to decrease a sum with the minimum number of operations, we pick the biggest numbers first. And that is what we do. Since we are picking numbers, altering them, and then adding them back into a sorted collection of elements, this follows the benefits of a heap.                                                                                                                                                                                                                                                                                                                                             |Concept: 1) Use a max heap to greedily retrieve the maximum value element to halve, which maximizes the depletion rate, thus minimizing the total number of operations.                                                                                                                                                                                                                        |
|Heap / Greedy                   |M      |[](https://leetcode.com/problems/maximum-score-from-removing-stones/description/)[1753](https://leetcode.com/problems/maximum-score-from-removing-stones/description/)                              |[](https://github.com/BrandonKenter/Solutions/blob/main/Heap/LC1753-maximumScoreFromRemovingStones.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Heap/LC1753-maximumScoreFromRemovingStones.py)                      |Maximum Score From Removing Stones               |This follows the common problem pattern where we are getting the min/max from a collection of elements, altering them, and then adding them back to the collection of elements multiple times. This problem pattern uses a heap data structure to do this efficiently.                                                                                                                                                                                                                                                                                                                                                                                       |Concept: 1) Use a max heap to greedily retrieve the max element in a collection of elements to maximize the sum.                                                                                                                                                                                                                                                                               |
|Kth Largest / Smallest          |:lemon:|                                                                                                                                                                                                    |                                                                                                                                                                                                                                      |                                                 |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |                                                                                                                                                                                                                                                                                                                                                                                               |
|Array / Heap                    |M      |[](https://leetcode.com/problems/find-the-kth-largest-integer-in-the-array/)[1985](https://leetcode.com/problems/find-the-kth-largest-integer-in-the-array/)                                        |[](https://github.com/BrandonKenter/Solutions/blob/main/Heap/LC1985-findTheKthLargestIntegerInTheArray.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Heap/LC1985-findTheKthLargestIntegerInTheArray.py)              |Find the Kth Largest Integer in the Array        |Important note: The wording for these problems can often be confusing. Kth largest means the kth element in a sorted collection of elements. For max heap, we heapify the entire array first so that the heap is in increasing to decreasing order. This means k pops will get our answer. For a min heap, we are making sure no more than k numbers are in the heap. After each push/pop, the kth + 1 largest element will be evicted from the heap. Max heap is O(KlogN + N) and min heap is O(NlogK). When K >= n/2, O(NlogK) will be better than O(KlogN + N).                                                                                           |Concept: 1) Use a min heap of size k, popping from the heap when the size is k + 1. The next pop after the last integer is added is the Kth largest integer. 2) Heapify the given array to make it a max heap and the Kth pop is the Kth largest integer.                                                                                                                                      |
|Matrix / Heap                   |M      |[](https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/)[378](https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/)                                             |                                                                                                                                                                                                                                      |Kth Smallest Element in a Sorted Matrix          |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |Concept: 1) Use a max heap of size k, popping from the heap when the size is k + 1. The next pop after the last integer is added is the Kth smallest integer. 2) Heapify the given array to make it a min heap and the Kth pop is the Kth smallest integer.                                                                                                                                    |
|K Largest / Smallest            |:lemon:|                                                                                                                                                                                                    |                                                                                                                                                                                                                                      |                                                 |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |                                                                                                                                                                                                                                                                                                                                                                                               |
|Array / String / Heap           |E      |[](https://leetcode.com/problems/find-subsequence-of-length-k-with-the-largest-sum/description/)[2099](https://leetcode.com/problems/find-subsequence-of-length-k-with-the-largest-sum/description/)|[](https://github.com/BrandonKenter/Solutions/blob/main/Heap/LC2099-findSubsequenceOfLengthKWithTheLargestSum.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Heap/LC2099-findSubsequenceOfLengthKWithTheLargestSum.py)|Find Subsequence of Length K With the Largest Sum|To find the subsequence, we need to find the k largest numbers in nums. To do this we could sort or use a min heap. Sorting is O(Nlog(N)) time, while using a min heap is O(Nlog(K)) time because we can pop from the min heap when the min heap length is > k (popping the smallest value), meaning pushing and popping is at most log(K) time and we do this N times. Then to recover the subsequence IN ORDER, we just need to get the counts of each value in the min heap, lienarly iterate through the nums array and when we see a num that is in the count hash map, add it to the result list and decrement the count of that value in the hash map.|Concept: 1) Use a min heap of size K to get a collection of the K largest elements. 2) If subsequence sum is the only concern, the order of the elements in the subsequence does not matter.                                                                                                                                                                                                   |
|Array / String / Hash Map / Heap|M      |[](https://leetcode.com/problems/top-k-frequent-words/)[692](https://leetcode.com/problems/top-k-frequent-words/)                                                                                   |                                                                                                                                                                                                                                      |Top K Frequent Words                             |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |Concept: 1) To get K most frequent, use counter and pop k most.                                                                                                                                                                                                                                                                                                                                |
|Min / Max Element               |:lemon:|                                                                                                                                                                                                    |                                                                                                                                                                                                                                      |                                                 |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |                                                                                                                                                                                                                                                                                                                                                                                               |
|Array / Heap                    |E      |[](https://leetcode.com/problems/last-stone-weight/)[1046](https://leetcode.com/problems/last-stone-weight/)                                                                                        |[](https://github.com/BrandonKenter/Solutions/blob/main/Heap/LC1046-lastStoneWeight.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Heap/LC1046-lastStoneWeight.py)                                                    |Last Stone Weight                                |We are deleting and adding to an sorted ordering of numbers. This follows the criteria for a problem pattern that tends to require a heap to solve it optimally. Getting the largest or smallest element repeatedly leans toward a heap solution.                                                                                                                                                                                                                                                                                                                                                                                                            |Concept: 1) Use a max heap to retrieve the max two elements from a collection of elements repeatedly.                                                                                                                                                                                                                                                                                          |
|Array / Hash Map / Heap         |M      |[](https://leetcode.com/problems/least-number-of-unique-integers-after-k-removals/description/)[1481](https://leetcode.com/problems/least-number-of-unique-integers-after-k-removals/description/)  |                                                                                                                                                                                                                                      |Least Number of Unique Integers after K Removals |Good greedy heap problem. Uses the pattern of counts hash map + heap.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |Concept: 1) Counts hash map. 2) Use a min heap to greedily retrieve the minimum count element to decrease.                                                                                                                                                                                                                                                                                     |
|Array / Heap                    |M      |[](https://leetcode.com/problems/single-threaded-cpu/)[1834](https://leetcode.com/problems/single-threaded-cpu/)                                                                                    |                                                                                                                                                                                                                                      |Single-Threaded CPU                              |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |                                                                                                                                                                                                                                                                                                                                                                                               |
|K Lists                         |:lemon:|                                                                                                                                                                                                    |                                                                                                                                                                                                                                      |                                                 |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |                                                                                                                                                                                                                                                                                                                                                                                               |
|Linked List / Heap              |H      |[](https://leetcode.com/problems/merge-k-sorted-lists/)[23](https://leetcode.com/problems/merge-k-sorted-lists/)                                                                                    |                                                                                                                                                                                                                                      |Merge k Sorted Lists                             |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |Concept: 1) K lists min heap.                                                                                                                                                                                                                                                                                                                                                                  |
|Array / Heap                    |H      |[](https://leetcode.com/problems/smallest-range-covering-elements-from-k-lists/)[632](https://leetcode.com/problems/smallest-range-covering-elements-from-k-lists/)                                 |                                                                                                                                                                                                                                      |Smallest Range from K Lists                      |To get the minimum range, we can start by choosing the minimum of each list. The next step is to remove the minimum value between the k lists and consider its next element. Moving the minimum index to the right guarantees we are checking possible pairings that have the smallest range.                                                                                                                                                                                                                                                                                                                                                                |Concept: 1) K lists min heap.                                                                                                                                                                                                                                                                                                                                                                  |
|Misc                            |:lemon:|                                                                                                                                                                                                    |                                                                                                                                                                                                                                      |                                                 |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |                                                                                                                                                                                                                                                                                                                                                                                               |
|Array / Heap                    |M      |[](https://leetcode.com/problems/process-tasks-using-servers/)[1882](https://leetcode.com/problems/process-tasks-using-servers/)                                                                    |                                                                                                                                                                                                                                      |Process Tasks Using Servers                      |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |Concept: 1) Two heaps.                                                                                                                                                                                                                                                                                                                                                                         |
|Heap                            |H      |[](https://leetcode.com/problems/find-median-from-data-stream/)[295](https://leetcode.com/problems/find-median-from-data-stream/)                                                                   |[](https://github.com/BrandonKenter/Solutions/blob/main/Heap/LC295-findMedianFromDataStream.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Heap/LC295-findMedianFromDataStream.py)                                    |Find Median from Data Stream                     |Finding the median in an array of numbers is simple, but complexity is added if the array of numbers is instead a stream of numbers, and finding the median is a frequent operation. This is when we want to efficiently have access to the median of the array of values without having to traverse all N values. This is where the concept of using a min and max heap together to separate the stream of values into two parts and every time a number is added, work is done to maintain these halves.                                                                                                                                                   |Concept: 1) Use min and max heap to find the median value in a data stream.                                                                                                                                                                                                                                                                                                                    |

## Counting Sort

|Greedy                           |:lemon:|                                                                                                                                                            |                                                                                                                                                                                                                |                              |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |                                                                                                                                                                                                                                                                                       |
|---------------------------------|-------|------------------------------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|Array / Counting Sort            |M      |[](https://leetcode.com/problems/reduce-array-size-to-the-half/description/)[1338](https://leetcode.com/problems/reduce-array-size-to-the-half/description/)|[](https://github.com/BrandonKenter/Solutions/blob/main/Hash%20Map/LC1338-reduceArraySizeToTheHalf.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Hash%20Map/LC1338-reduceArraySizeToTheHalf.py)|Reduce Array Size to The Half |Use this as example to sort dictionaries based on value (frequency) using lambda.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |Concept: 1) Use a frequency array to store the integers in sorted order based on their frequency and iterate through the frequency array from right to left to greedily decrease the array size by the most possible for each chocie.                                                  |
|K Most / Least Frequent          |:lemon:|                                                                                                                                                            |                                                                                                                                                                                                                |                              |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |                                                                                                                                                                                                                                                                                       |
|Matrix / Counting Sort           |E      |[](https://leetcode.com/problems/the-k-weakest-rows-in-a-matrix/)[1337](https://leetcode.com/problems/the-k-weakest-rows-in-a-matrix/)                      |[](https://github.com/BrandonKenter/Solutions/blob/main/Heap/LC1337-theKWeakestRowsInAMatrix.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Heap/LC1337-theKWeakestRowsInAMatrix.py)            |The K Weakest Rows in a Matrix|Since problem asks for ordering of frequency ties to be from lower index to higher index, we can use counting sort. This is because ties will naturally be placed correctly if we iterate from the first to last row.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |Concept: 1) Use a frequency array to store the row weaknesses in sorted order and iterate through the frequency array starting from left to right to get the K weakest rows.                                                                                                           |
|Sort by Frequency                |:lemon:|                                                                                                                                                            |                                                                                                                                                                                                                |                              |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |                                                                                                                                                                                                                                                                                       |
|String / Counting Sort           |E      |[](https://leetcode.com/problems/increasing-decreasing-string/description/)[1370](https://leetcode.com/problems/increasing-decreasing-string/description/)  |[](https://github.com/BrandonKenter/Solutions/blob/main/String/LC1370-increasingDecreasingString.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/String/LC1370-increasingDecreasingString.py)    |Increasing Decreasing String  |We need to maintain some type of count for the characters we choose from, pick one character at each iteration, and make sure the next is greater than the previous from left to right and then the next smaller than the previous from right to left. This follows perfectly with what an array can provide us. But how do we do char -> array index mappings? Python's ord function. We can use an array of size 26 and 'a' corresponds to 0, 'b' corresponds to 1 etc. To do this char -> index mapping, we do 'char - ord('a')'. This gives us an integer from 0-26 for lowercase letters. Then when we want to get the char back from this index number, we do chr(i + ord('a')), which is essentially doing the reverse.                                                                                                                                                                                                                                                                                                                                  |Concept: 1) Convert character to ordinal value. 2) Counting sort using character ordinal values.                                                                                                                                                                                       |
|Array / Counting Sort            |E      |[](https://leetcode.com/problems/relative-sort-array/description/)[1122](https://leetcode.com/problems/relative-sort-array/description/)                    |[](https://github.com/BrandonKenter/Solutions/blob/main/Hash%20Map/LC1122-relativeSortArray.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Hash%20Map/LC1122-relativeSortArray.py)              |Relative Sort Array           |Since we want to add to the result array the numbers seen in arr2 in order, we will linearly iterate through arr2. To find if the current number we are at in the arr2 traversal is in the arr1 efficiently, we use a set that contains the elements in arr1 for a quick O(1) lookup. Then when we find out this number in arr2 is also a number in arr1, we need the frequency of it in arr1. To do this, we first find the frequency of all numbers. Here we have to make a decision of using a hash map or array to encode the frequencies. Since we need to add elements that are not seen in arr2 in ASCENDING order, we choose to use an array as the indices of an array that encode the element number are naturally in ascending order. Also, when we are adding all the elements that are both in arr2 and arr1 to res, we can change the frequency in the array to 0. That way when we do the part of the algorithm where we have to add the remaining elements in ascending order, we just append the elements that have a frequency greater than 0.|Concept: 1) Use a frequency array to store the frequency of each element where the array index represent the integer and the value at that index represents the frequency. 2) Use the frequency array to avoid sorting time complexity when needing to retrieve values in sorted order.|
|String / Hash Map / Counting Sort|M      |[](https://leetcode.com/problems/sort-characters-by-frequency/)[451](https://leetcode.com/problems/sort-characters-by-frequency/)                           |[](https://github.com/BrandonKenter/Solutions/blob/main/String/LC451-sortCharactersByFrequency.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/String/LC451-sortCharactersByFrequency.py)        |Sort Characters by Frequency  |This is a bucket sort problem and very similar to LC 347 - "Top K Frequent Elements". The brute-force approach is to either get the frequencies via a Counter and sort based on frequencies or create a max heap of the chars based on their frequencies and getting the max element from the max heap until it is empty. This is O(Nlog(N)) time. But we can solve this problem in O(N) time by doing bucket sort. We have len(s) + 1 arrays inside of a frequency array. Each indexed array represents a frequency seen and the elements inside the array are the chars at that frequency. Iterating from the back of the frequency list to the front gets the most frequent to least frequent chars.                                                                                                                                                                                                                                                                                                                                                         |Concept: 1) Use a frequency array to store the characters in sorted order based on their frequency and iterate through the frequency array from right to left to build up the sorted string based on frequency.                                                                        |

## Linked List

|Trivial Pointer Ops                       |:lemon:|                                                                                                                                                                |                                                                                                                                                                                                                          |                                |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |                                                                                                                                                              |
|------------------------------------------|-------|----------------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------|
|Linked List                               |E      |[](https://leetcode.com/problems/merge-two-sorted-lists/)[21](https://leetcode.com/problems/merge-two-sorted-lists/)                                            |[](https://github.com/BrandonKenter/Solutions/blob/main/Linked%20List/LC21-mergeTwoSortedLists.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Linked%20List/LC21-mergeTwoSortedLists.py)                  |Merge Two Sorted Lists          |One thing that people misunderstand about pointer manipulation problems is they think that these are linear time algorithms. But it must be understood that the new memory being allocated is only for a singular dummy node and a reference to that dummy node. Everything else is just shifting pointers around. If you think of a list node in memory, it has a space for data to store a reference to the next node. We are just updating this data to different data. We aren't adding any new data.                                                                                                                                                                                                                                                                                                                              |Concept: Merge two sorted linked lists into a single sorted linked list.                                                                                      |
|Linked List / Math                        |M      |[](https://leetcode.com/problems/add-two-numbers/)[2](https://leetcode.com/problems/add-two-numbers/)                                                           |[](https://github.com/BrandonKenter/Solutions/blob/main/Linked%20List/LC2%20-%20addTwoNumbers.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Linked%20List/LC2%20-%20addTwoNumbers.py)                    |Add Two Numbers                 |To add two numbers in base 10, we use a carry and add the two digits along with the carry together. The new carry is this place's sum divided by 10 and the digit is this place's sum modulo 10. We iterate while l1 or l2 or carry because as long as one of them exists, we still need to add digits to our number.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |Concept: 1) Traverse two lists simultaneously, adding the nodes together like you would add two numbers together digit-by-digit (with a carry). 2) Dummy node.|
|Linked List                               |M      |[](https://leetcode.com/problems/odd-even-linked-list/)[328](https://leetcode.com/problems/odd-even-linked-list/)                                               |                                                                                                                                                                                                                          |Odd Even Linked List            |While even and even.next, update odd and even's next references, then join at end.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |Concept: 1) Pointer manipulation                                                                                                                              |
|Reverse List                              |:lemon:|                                                                                                                                                                |                                                                                                                                                                                                                          |                                |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |                                                                                                                                                              |
|Linked List / Recursion                   |E      |[](https://leetcode.com/problems/reverse-linked-list/)[206](https://leetcode.com/problems/reverse-linked-list/)                                                 |[](https://github.com/BrandonKenter/Solutions/blob/main/Linked%20List/LC206-reverseLinkedList.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Linked%20List/LC206-reverseLinkedList.py)                    |Reverse Linked List             |The tricky parts to this problem are: startin with prev = None, creating a tmp variable to store head.next, and returning prev. Using a tmp variable to store a reference that will be overwritten is a very common practice with linked list problems.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |Concept: Reverse a linked list.                                                                                                                               |
|Linked List                               |H      |[](https://leetcode.com/problems/reverse-nodes-in-k-group/)[25](https://leetcode.com/problems/reverse-nodes-in-k-group/)                                        |                                                                                                                                                                                                                          |Reverse Nodes in k-Group        |Reverse LL in k-groups. Use getKth hepler. Iterate while True, return when not kth.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |Concept: 1) Reverse linked list in k-groups. 2) Dummy node.                                                                                                   |
|Slow & Fast                               |:lemon:|                                                                                                                                                                |                                                                                                                                                                                                                          |                                |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |                                                                                                                                                              |
|Linked List                               |E      |[](https://leetcode.com/problems/middle-of-the-linked-list/)[876](https://leetcode.com/problems/middle-of-the-linked-list/)                                     |[](https://github.com/BrandonKenter/Solutions/blob/main/Linked%20List/LC876-middleOfLinkedList.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Linked%20List/LC876-middleOfLinkedList.py)                  |Middle of the Linked List       |This is one of the linked list problems where you have to pay close attention to off-by-one errors. Firstly, you have to think about where you want the fast and slow pointers to start. Then you have to think about lists with an odd number of nodes or an even number of nodes. You have to run through test casees to prove to your interviewer that the algorithm works for all reasonable cases.                                                                                                                                                                                                                                                                                                                                                                                                                                |Concept: 1) Find the middle node in a linked list using slow & fast pointers.                                                                                 |
|Linked List                               |E      |[](https://leetcode.com/problems/linked-list-cycle/)[141](https://leetcode.com/problems/linked-list-cycle/)                                                     |[](https://github.com/BrandonKenter/Solutions/blob/main/Linked%20List/LC141-linkedListCycle.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Linked%20List/LC141-linkedListCycle.py)                        |Linked List Cycle               |This is the classic example of a slow and fast pointer problem. It is also referred to as Floyd's cycle or hair-tortoise. The idea is that two pointers will always converge on each other if one is increasing in distance from the other by 1 at each iteration, which, in a cycle, means they are actually getting closer by 1 at each iteration.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |Concept: 1) Detect if there is a cycle in a linked list using slow & fast pointers.                                                                           |
|Delete Nodes                              |:lemon:|                                                                                                                                                                |                                                                                                                                                                                                                          |                                |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |                                                                                                                                                              |
|Linked List                               |E      |[](https://leetcode.com/problems/remove-linked-list-elements/)[203](https://leetcode.com/problems/remove-linked-list-elements/)                                 |[](https://github.com/BrandonKenter/Solutions/blob/main/Linked%20List/LC203-removeLinkedListElements.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Linked%20List/LC203-removeLinkedListElements.py)      |Remove Linked List Elements     |We need a dummy reference because there is an edge case where a node to be removed is the head node. In that case, we need a node before the head node. With these reference changing problems in-place in O(N) time, it really is just a matter of coming up with an ad hoc traversal and update algorithm. What we do know at the start is we need a dummy and we have to update while cur. We also know that if cur.val == val, we want to update cur's previous node to point to cur's next node. The important next idea is to not update prev yet. If shift prev and cur's next also has a val == val, we lose the reference to prev to update it's next reference ahead again. This edge case is when 2 or more nodes together have a val == val. After being able to reason through this, the code then becomes fairly trivial.|Concept: 1) Remove nodes from linked list that match a provided value. Very similar to LC 83 and LC 1836.                                                     |
|Linked List                               |M      |[](https://leetcode.com/problems/merge-nodes-in-between-zeros/)[2181](https://leetcode.com/problems/merge-nodes-in-between-zeros/)                              |[](https://github.com/BrandonKenter/Solutions/blob/main/Linked%20List/LC2181-mergeNodesInBetweenZeros.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Linked%20List/LC2181-mergeNodesInBetweenZeros.py)    |Merge Nodes in Between Zeros    |Since we will always remove the first node from the list, we don't need a dummy node. And since we are guaranteed to have three nodes, the first and last of which being 0's, we can start our traversal with prev being the first node after the first 0 and cur being the second node after the first 0. Then we can use two cases for each step: If the current value is 0, we update prev. If the current value is not 0, we increment prev by the current value.                                                                                                                                                                                                                                                                                                                                                                  |Concept: 1) Merge nodes values together between a target value.                                                                                               |
|Kth From End                              |:lemon:|                                                                                                                                                                |                                                                                                                                                                                                                          |                                |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |                                                                                                                                                              |
|Linked List                               |M      |[](https://leetcode.com/problems/swapping-nodes-in-a-linked-list/description/)[1721](https://leetcode.com/problems/swapping-nodes-in-a-linked-list/description/)|[](https://github.com/BrandonKenter/Solutions/blob/main/Linked%20List/LC1721-swappingNodesInALinkedList.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Linked%20List/LC1721-swappingNodesInALinkedList.py)|Swapping Nodes in a Linked List |This is a common subpattern in linked list problems where you have to find the kth node from the end of the list. To do this, we use a left and right pointer. The right pointer will be used to stop when we hit a null node. Then we want the gap between the left and right pointer to be such that the left pointer is at the kth node from the end of the linked list when right is null. There are many ways you can code this, but the general way is to first create the necessary gap between left and right by shifting right forward, then shift left and right simultaneously until right.next is null (or right is null depending on how you want to code it).                                                                                                                                                            |Concept: 1) Find kth node from beginning and kth from end of a linked list.                                                                                   |
|Linked List                               |M      |[](https://leetcode.com/problems/remove-nth-node-from-end-of-list/)[19](https://leetcode.com/problems/remove-nth-node-from-end-of-list/)                        |[](https://github.com/BrandonKenter/Solutions/blob/main/Linked%20List/LC19-removeNthNodeFromEndOfList.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Linked%20List/LC19-removeNthNodeFromEndOfList.py)    |Remove Nth Node From End of List|We use a dummy node because the node to remove could be the first node. So we need a reference to the node before it, which in this case has to be a dummy node that we create. The first while loop is essentially creating a gap between left and right so that when right is eventually None on the second loop, our left pointer is at the node before the node we want to remove.                                                                                                                                                                                                                                                                                                                                                                                                                                                 |Concept: 1) Remove Nth node from end of list.                                                                                                                 |
|Doubly-linked List                        |:lemon:|                                                                                                                                                                |                                                                                                                                                                                                                          |                                |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |                                                                                                                                                              |
|Linked List / Doubly-Liked List / Hash Map|M      |[](https://leetcode.com/problems/lru-cache/)[146](https://leetcode.com/problems/lru-cache/)                                                                     |                                                                                                                                                                                                                          |LRU Cache                       |Doubly linked list. A seemingly common interview question for linekd list.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |Concept: 1) Use a doubly-linked list to implement an LRU cache.                                                                                               |
|Linked List / Doubly-Liked List           |M      |[](https://leetcode.com/problems/design-circular-queue/)[622](https://leetcode.com/problems/design-circular-queue/)                                             |                                                                                                                                                                                                                          |Design Circular Queue           |Linked list. Left and right nodes. Enque right, deque left. Use self.space for space left.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |Concept: 1) Doubly-linked list.                                                                                                                               |
|Misc                                      |:lemon:|                                                                                                                                                                |                                                                                                                                                                                                                          |                                |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |                                                                                                                                                              |
|Linked List                               |M      |[](https://leetcode.com/problems/sort-list/)[148](https://leetcode.com/problems/sort-list/)                                                                     |[](https://github.com/BrandonKenter/Solutions/blob/main/Linked%20List/LC148-sortList.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Linked%20List/LC148-sortList.py)                                      |Sort List                       |We can treat sortList() as a recursive method. We use left and right variables as the start of the left list and the right list after the mid node respectively. To get the right node after mid, we implement a getMid() helper method. Once we have references to both left and right lists, we then return the merged list of these two lists, which is implemented as a helper method merge(). This returned merged list will return back up the recursive tree so that previous calls can use this merged list to merge with the other list in that execution context.                                                                                                                                                                                                                                                            |Concept: 1) Use merge sorted linked list idea in conjunction with the merge sort idea.                                                                        |
|Linked List / Hash Map                    |M      |[](https://leetcode.com/problems/copy-list-with-random-pointer/)[138](https://leetcode.com/problems/copy-list-with-random-pointer/)                             |[](https://github.com/BrandonKenter/Solutions/blob/main/Linked%20List/LC138-copyListWithRandomPointer.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Linked%20List/LC138-copyListWithRandomPointer.py)    |Copy List with Random Pointer   |Seed the old_to_new hash map with None : None because we will get a key error for None otherwise. The reason we need to do two passes is because the first pass is to create new instances of the old nodes, but we can't reference next or random because next hasn't been create yet and random could be any node. This is why we make sure we have every possible node in the hash map before we try to update pointers.                                                                                                                                                                                                                                                                                                                                                                                                            |Concept: 1) Create deep copy of linked list that has a random pointer.                                                                                        |

## Sliding Window

|Static Size                            |:lemon:|                                                                                                                                                                                                                |                                                                                                                                                                                                                                                                                    |                                                         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |                                                                                                                                                                                                                                                                                                                                                                               |
|---------------------------------------|-------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|String / Sliding Window                |E      |[](https://leetcode.com/problems/minimum-recolors-to-get-k-consecutive-black-blocks/description/)[2379](https://leetcode.com/problems/minimum-recolors-to-get-k-consecutive-black-blocks/description/)          |[](https://github.com/BrandonKenter/Solutions/blob/main/Sliding%20Window/LC2379-minimumRecolorsToGetKConsecutiveBlackBlocks.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Sliding%20Window/LC2379-minimumRecolorsToGetKConsecutiveBlackBlocks.py)                  |Minimum Recolors to Get K Consecutive Black Blocks       |Since we have to get the minimum recolors out of all the size k windows, this is a sliding window problem of fixed size. To solve the problem, we just have to find the minimum number of white blocks in each k-size window. As a side note, since we are minimizing, we want to start the answer as float('inf'). You always want to start the value we are trying to minimize/maximize as the opposite infinite value so no matter how extreme an edge case gets, we will still update the value.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |Concept: 1) Static-size dynamic window. 2) Find minimum frequency of a specific element in the sliding window of size k.                                                                                                                                                                                                                                                       |
|String / Sliding Window                |M      |[](https://leetcode.com/problems/minimum-number-of-flips-to-make-the-binary-string-alternating/)[1888](https://leetcode.com/problems/minimum-number-of-flips-to-make-the-binary-string-alternating/)            |[](https://github.com/BrandonKenter/Solutions/blob/main/Sliding%20Window/LC1888-minimumNumberOfFlipsToMakeTheBinaryStringAlternating.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Sliding%20Window/LC1888-minimumNumberOfFlipsToMakeTheBinaryStringAlternating.py)|Minimum Number of Flips to Make Binary String Alternating|We can use a sliding mask to compare the current number to strings that alternate starting with 0/1, maintaining a difference count for each mask. We can do this for a string that is two copies of the original string to explore all possible situations where we remove a character from the start of the string and append it to the end.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |Concept: 1) Static-size sliding window. 2) Double string to simulate possibilities of moving left element to end.                                                                                                                                                                                                                                                              |
|String / Hash Map / Sliding Window     |M      |[](https://leetcode.com/problems/find-all-anagrams-in-a-string/)[438](https://leetcode.com/problems/find-all-anagrams-in-a-string/)                                                                             |[](https://github.com/BrandonKenter/Solutions/blob/main/Sliding%20Window/LC438-findAllAnagramsInAString.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Sliding%20Window/LC438-findAllAnagramsInAString.py)                                                          |Find All Anagrams in a String                            |Since we are limited to 26 characters, the space complexity can be at most 26 entries for each hash map, or 52 total, which is O(1) since any constant is just O(1). This is considered a fixed-window size sliding window problem because our window size is not dynamic. It is constantly the length of p. This is because no substring can be an anagram of p if it is shorter or longer. it has to be the exact length of p. Because of this, the updating of the window indices is trivial for these problems.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |Concept: 1) Static-size sliding window with implicit window size. 2) Hash map to keep track of window character counts.                                                                                                                                                                                                                                                        |
|Array / Sliding Window                 |M      |[](https://leetcode.com/problems/minimum-swaps-to-group-all-1s-together-ii/)[2134](https://leetcode.com/problems/minimum-swaps-to-group-all-1s-together-ii/)                                                    |[](https://github.com/BrandonKenter/Solutions/blob/main/Sliding%20Window/LC2134-minimumSwapsToGroupAll1sTogetherII.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Sliding%20Window/LC2134-minimumSwapsToGroupAll1sTogetherII.py)                                    |Minimum Swaps to Group All 1's Together II               |Reall good sliding window problem that introduces the idea of finding a window size based on the elements.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |Concept: 1) Static-size sliding window with implicit window size. 2) Duplicate array to mimic circular array.                                                                                                                                                                                                                                                                  |
|Array / Queue / Sliding Window         |H      |[](https://leetcode.com/problems/sliding-window-maximum/)[239](https://leetcode.com/problems/sliding-window-maximum/)                                                                                           |[](https://github.com/BrandonKenter/Solutions/blob/main/Sliding%20Window/LC239-slidingWindowMaximum.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Sliding%20Window/LC239-slidingWindowMaximum.py)                                                                  |Sliding Window Maximum                                   |We use a monotonically decreasing queue so the max in each window is present in the queue. We can pop because those numbers will never be the max if the current number is larger. We have to popleft with two different conditions because we can either have a situation where the queue is larget than k and also we could have got rid of every other element in the queue, leaving one element. If we pop this new element and the next element is smaller than the popped element, we would append the smaller element to the answer array, which is incorrect.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |Concept: 1) Static-size sliding window with an explicit window size. 2) Use a monotonically increasing queue for the window to have efficient access to the maximum element of the window on the right and to pop from the left when shrinking from the left.                                                                                                                  |
|Dynamic: Minimize                      |:lemon:|                                                                                                                                                                                                                |                                                                                                                                                                                                                                                                                    |                                                         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |                                                                                                                                                                                                                                                                                                                                                                               |
|Array / Sliding Window                 |M      |[](https://leetcode.com/problems/minimum-size-subarray-sum/)[209](https://leetcode.com/problems/minimum-size-subarray-sum/)                                                                                     |[](https://github.com/BrandonKenter/Solutions/blob/main/Sliding%20Window/LC209-minimumSizeSubarraySum.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Sliding%20Window/LC209-minimumSizeSubarraySum.py)                                                              |Minimum Size Subarray Sum                                |This is a standard dynamic-size sliding window problem. To do a dyanmic-size sliding window algorithm for the context of this problem, use a for loop to always add the right value to the window sum. After adding it to the window sum, update min_len with the minimum of min_len and the current window size and shrink the left side while we are still greater than or equal to the target value. The window will continue shrinking until our win_sum is < target. This works because we are building up to a target sum. So the values between left and right will never have to be recomputed since they can never equal the target sum on their own after we break out of the while loop.                                                                                                                                                                                                                                                                                                                                                                                                                                                           |Concept: 1) Dynamic-size minimize sliding window. Shrink from left when target is met until target is not met.                                                                                                                                                                                                                                                                 |
|Array / Hash Map / Sliding Window      |M      |[](https://leetcode.com/problems/minimum-consecutive-cards-to-pick-up/description/)[2260](https://leetcode.com/problems/minimum-consecutive-cards-to-pick-up/description/)                                      |[](https://github.com/BrandonKenter/Solutions/blob/main/Sliding%20Window/LC2260-minimumConsecutiveCardsToPickUp.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Sliding%20Window/LC2260-minimumConsecutiveCardsToPickUp.py)                                          |Minimum Consecutive Cards to Pick Up                     |This is a sliding window of dynamic size because the length of the sliding window is unknown. We want to stop expanding the sliding window when we find a duplicate card. We stop expanding because we want to minimize the window that contains a matching. So when we find a matching, we shrink from the left and keep trying to update the min_consec. When we shrink the window to a point where there is no matching, we try to grow the window size again.We use a cur_max_count so we don't have to continuously call max(card_counts.values()) in the while loop condition, which gives TLE. It's faster to maintain/check 1 variable's value rather than going through all values in card_counts.                                                                                                                                                                                                                                                                                                                                                                                                                                                   |Concept: 1) Dynamic-size sliding window. 2) Minimizing sliding window. 3) Minimum window size with 2 of the same element.                                                                                                                                                                                                                                                      |
|Array / Hash Map / Sliding Window      |H      |[](https://leetcode.com/problems/minimum-window-substring/)[76](https://leetcode.com/problems/minimum-window-substring/)                                                                                        |[](https://github.com/BrandonKenter/Solutions/blob/main/Sliding%20Window/LC76-minWinSubstring.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Sliding%20Window/LC76-minWinSubstring.py)                                                                              |Minimum Window Substring                                 |This is a subpattern of sliding window that I like to call 'dynamic-sized'. This means that the window is growing or shrinking depending on certain criteria, or essentially we do not know what the window size will be during iteration. Using a left pointer starting at 0 and iterating through the array with a for loop using a right pointer has worked for the problems I can think of off of the top of my head, but there may be other questions that require a different traversal. As for the other trick to this problem which makes it a hard is comparing the counts of the window hash map and the t count hash map. Using have and need variables chances the time complexity from O(26) for checking every character in both hash maps to O(1) where we only need to check 1 variable (have).                                                                                                                                                                                                                                                                                                                                               |Concept: 1) Dynamic-size minimize sliding window. Shrink from left when target is met until target is not met. 2) Use extra variables to track constraint to avoid comparing window character counts to target string character counts at each iteration.                                                                                                                      |
|Sliding Window                         |M      |[](https://leetcode.com/problems/replace-the-substring-for-balanced-string/description/)[1234](https://leetcode.com/problems/replace-the-substring-for-balanced-string/description/)                            |                                                                                                                                                                                                                                                                                    |Replace the Substring for Balanced String                |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |Concept: 1) Dynamic-size sliding window minimizing. 2) Get excess count of elements and get minimum window that has the excess elements in it. 3) Minimum with AT LEAST k elements.                                                                                                                                                                                            |
|Dynamic: Maximize                      |:lemon:|                                                                                                                                                                                                                |                                                                                                                                                                                                                                                                                    |                                                         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |                                                                                                                                                                                                                                                                                                                                                                               |
|String / Sliding Window / Hash Map     |M      |[](https://leetcode.com/problems/longest-substring-without-repeating-characters/)[3](https://leetcode.com/problems/longest-substring-without-repeating-characters/)                                             |[](https://github.com/BrandonKenter/Solutions/blob/main/Sliding%20Window/LC3-longestSubstringWithoutRepeatingCharacters.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Sliding%20Window/LC3-longestSubstringWithoutRepeatingCharacters.py)                          |Longest Substring Without Repeating Characters           |This is a sliding window of dynamic size. It is important to distinguish these between fixed-size sliding windows so you can generalize approaches to apply them to other problems. For this approach, the dynamic nature is with the while loop that shrinks the window until s[right] is not in the window.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |Concept: 1) Dynamic-size maximizing sliding window. 2) Hash set to keep track of window characters. 3) While window constraint is broken, remove left value from window data structure and increment left by 1.                                                                                                                                                                |
|Array / Sliding Window / Hash Map      |M      |[](https://leetcode.com/problems/fruit-into-baskets/description/)[904](https://leetcode.com/problems/fruit-into-baskets/description/)                                                                           |[](https://github.com/BrandonKenter/Solutions/blob/main/Sliding%20Window/LC904-fruitIntoBaskets.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Sliding%20Window/LC904-fruitIntoBaskets.py)                                                                          |Fruit Into Baskets                                       |Similar to LC 159 and LC 340. This is a dynamic size subpattern because the length of the sliding window is unknown. The problem description is verbose, but the pattern follows a standard dynamic sliding window approach where we add the newly seen element at the right index to a collection, shrink the left side of the sliding window while we passed our condition, and then take the maximum of the current maximum and our current window size.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |Concept: 1) Dynamic-size sliding window. 2) Constraint is a maximum number of unique elements in the window.                                                                                                                                                                                                                                                                   |
|Sliding Window / String                |M      |[](https://leetcode.com/problems/length-of-the-longest-alphabetical-continuous-substring/description/)[2414](https://leetcode.com/problems/length-of-the-longest-alphabetical-continuous-substring/description/)|                                                                                                                                                                                                                                                                                    |Length of the Longest Alphabetical Continuous Substring  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |Concept: 1) Dynamic-size sliding window. 2) Ordinal values.                                                                                                                                                                                                                                                                                                                    |
|Dynamic: Maximize With Replacements    |:lemon:|                                                                                                                                                                                                                |                                                                                                                                                                                                                                                                                    |                                                         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |                                                                                                                                                                                                                                                                                                                                                                               |
|Array / Sliding WIndow                 |M      |[](https://leetcode.com/problems/max-consecutive-ones-iii/)[1004](https://leetcode.com/problems/max-consecutive-ones-iii/)                                                                                      |[](https://github.com/BrandonKenter/Solutions/blob/main/Sliding%20Window/LC1004-maxConsecutiveOnesIII.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Sliding%20Window/LC1004-maxConsecutiveOnesIII.py)                                                              |Max Consecutive Ones III                                 |Note: this is the same exact implementation as "Max Consecutive Ones II", except instead of only being allowed one 0, we can have k 0's. This is a dynamic size subpattern because the length of the sliding window is unknown. For each iteration, we check if the new num we are adding to our window on the right is equal to 0 or 1. If it is 0, we increment the zero_count by 1. Since we can only replace k 1's, we shrink the left size until the zero_count of our window becomes k. (This while loop won't need to execute if there is up to k 0's in the window). Then when we reach the end of each iteration, we can take the max of the current window length and the current max because at this point in the iteration we are guaranteed to have less than k + 1 0's in our window.                                                                                                                                                                                                                                                                                                                                                           |Concept: 1) Dynamic-size sliding window with replacements. 2) Count variable to keep track of replacements.                                                                                                                                                                                                                                                                    |
|String / Hash Map / Sliding WIndow     |M      |[](https://leetcode.com/problems/maximize-the-confusion-of-an-exam/)[2024](https://leetcode.com/problems/maximize-the-confusion-of-an-exam/)                                                                    |[](https://github.com/BrandonKenter/Solutions/blob/main/Sliding%20Window/LC2024-maximizeTheConfusionOfAnExam.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Sliding%20Window/LC2024-maximizeTheConfusionOfAnExam.py)                                                |Maximize the Confusion of an Exam                        |This is a sliding window of dynamic size because the length of the sliding window is unknown. This problem is nearly identical to LC 424 - "Longest Repeating Character Replacement" in form. The idea is to try to expand the sliding window to the right as long as the difference between the window length and the max of t_count/f_count is less than or equal to k. This essentially means, expand the window until we exhaust k possible replacements. We do window size - max of t/f because that produces the frequency of the minimum character of the two. An important idea to wrap your head around as well is with the shrinking of the left side. We only shrink it by at most 1 time per for loop iteration (a lot of problems shrink the window size using a while loop for some condition) because we got the max sliding window size so far, so decreasing by one and adding by one at each subsequent iteration does no harm to finding the maximized final result. Once we get the current max, there is no reason to shrink smaller than max when we are trying to maximize WINDOW LENGTH. Do some examples to justify this to yourself.|Concept: 1) Dynamic-size sliding window. 2) Max consecutive with k replacements.                                                                                                                                                                                                                                                                                               |
|Array / Sliding WIndow                 |M      |[](https://leetcode.com/problems/frequency-of-the-most-frequent-element/)[1838](https://leetcode.com/problems/frequency-of-the-most-frequent-element/)                                                          |[](https://github.com/BrandonKenter/Solutions/blob/main/Sliding%20Window/LC1838-frequencyOfTheMostFrequentElement.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Sliding%20Window/LC1838-frequencyOfTheMostFrequentElement.py)                                      |Frequency of the Most Frequent Element                   |The trick is to understand that we can sort the nums and then compare the right side of a sliding window \* the length of the sliding window to the current sum of the sliding window to check how many operations are needed to make all numbers equal. This will be our shrinking rule.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |Concept: 1) Dynamic-size maximizing sliding window with replacements. 2) When condition (with replacements) is not met, shrink from left by 1.                                                                                                                                                                                                                                 |
|Dynamic: Maximize Contiguous Constraint|:lemon:|                                                                                                                                                                                                                |                                                                                                                                                                                                                                                                                    |                                                         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |                                                                                                                                                                                                                                                                                                                                                                               |
|Array / Sliding Window                 |E      |[](https://leetcode.com/problems/max-consecutive-ones/)[485](https://leetcode.com/problems/max-consecutive-ones/)                                                                                               |[](https://github.com/BrandonKenter/Solutions/blob/main/Sliding%20Window/LC485-maxConsecutiveOnes.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Sliding%20Window/LC485-maxConsecutiveOnes.py)                                                                      |Max Consecutive Ones                                     |This is the dynamic size subpattern because the length of the sliding window is unkown. For each iteration, we have two choices: 1) If nums[right] is a 1, attempt to update max_consec with the current size of the array. 2) Nums[right] isn't a 1, so we update left to right + 1 since that is the next possible start of the max consecutive ones.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |Concept: 1) Dynamic-size maximizing sliding window. 2) When window constraint is broken, update left index to right + 1 since entire window is invalid.                                                                                                                                                                                                                        |
|Array / Sliding Window                 |M      |[](https://leetcode.com/problems/number-of-smooth-descent-periods-of-a-stock/description/)[2110](https://leetcode.com/problems/number-of-smooth-descent-periods-of-a-stock/description/)                        |[](https://github.com/BrandonKenter/Solutions/blob/main/Sliding%20Window/LC2110-numberOfSmoothDescentPeriodsOfAStock.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Sliding%20Window/LC2110-numberOfSmoothDescentPeriodsOfAStock.py)                                |Number of Smooth Descent Periods of a Stock              |To count the number of subarrays we can use a sliding window technique. We start the count at 1 because our algorithm only adds the 1-length subarray at the right index, and we want left and right to start at 0 and 1 respectively for the first comparison (this just cleans up the code so you don't have to encode an exrta case in the for loop). The number of subarrays is right - left + 1 if the value at the right index extends the current smooth descent period, otherwise the number of subarrays is 1 (itself).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |Concept: 1) Dynamic-size contiguous adjacent constraint sliding window. 2) Count subarrays using formula n \* (n + 1) / 2. 3) If window constraint is broken (left and right values are not equal), update answer and update left index to right index.                                                                                                                        |
|Dynamic: Count Subs                    |:lemon:|                                                                                                                                                                                                                |                                                                                                                                                                                                                                                                                    |                                                         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |                                                                                                                                                                                                                                                                                                                                                                               |
|String / Hash Map / Sliding Window     |M      |[](https://leetcode.com/problems/number-of-substrings-containing-all-three-characters/description/)[1358](https://leetcode.com/problems/number-of-substrings-containing-all-three-characters/description/)      |[](https://github.com/BrandonKenter/Solutions/blob/main/Sliding%20Window/LC1358-numberOfSubstringsContainingAllThreeCharacters.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Sliding%20Window/LC1358-numberOfSubstringsContainingAllThreeCharacters.py)            |Number of Substrings Containing All Three Characters     |This is a dynamic size subpattern because the length of the sliding window is unkown. Since we are COUNTING ALL substrings of ANY size that include the three characters AT LEAST ONCE, it is not sufficient enough to iterate until we have a window with all 3 characters and shrink the left side, counting each window that meets the requirements. That approach would miss counting all of the substrings that can START at those indices we discard in future windows. So we instead count the left index doing the following: Upon exiting from the while loop, all the substrings starting at indices 0, 1 â¦ (left - 1) and ending at right satisfies the condition. Since there are 'left' such strings, we add left to substr_count.                                                                                                                                                                                                                                                                                                                                                                                                               |Concept: 1) Dynamic-size sliding window counting subarrays. 2) Counting number of subarrays that have AT LEAST some number of specified elements. 3) Add left index to count after shrinking left side to break the condition because the index is the number of different starting positions a subarray can start at and end at the right index that adhere to the constraint.|
|Array / Sliding Window                 |H      |[](https://leetcode.com/problems/count-subarrays-with-score-less-than-k/description/)[2302](https://leetcode.com/problems/count-subarrays-with-score-less-than-k/description/)                                  |                                                                                                                                                                                                                                                                                    |Count Subarrays With Score Less Than K                   |Thinking process: With each newly added element, shrink window from left until a valid window is made. Then every subarray in this window is valid. IMPORTANT: The number of subarrays is 1 + 2 + 3 ... + n, or n \* (n + 1) / 2. So it is sufficient to add the length of the sliding window to the count every time it is valid to get the answer.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |Concept: 1) Dynamic-size sliding window with contiguous constraint. 2) Count subarrays with value less than K. 3) Count subarrays by getting valid window and adding length of window to subarray count.                                                                                                                                                                       |
|Array / Sliding Window                 |M      |[](https://leetcode.com/problems/count-number-of-nice-subarrays/description/)[1248](https://leetcode.com/problems/count-number-of-nice-subarrays/description/)                                                  |[](https://github.com/BrandonKenter/Solutions/blob/main/Sliding%20Window/LC1248-countNumberOfNiceSubarrays.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Sliding%20Window/LC1248-countNumberOfNiceSubarrays.py)                                                    |Count Number of Nice Subarrays                           |Extremely similar to LC 560 Subarray Sum Equals to K. The reason this is different from something like LC 1358 is because we need EXACTLY k items. If we have AT LEAST k items constraint, technically we could start every subarray from the beginning. But with EXACTLY k items, we need a different approach. This problem can be solved with sliding window or prefix sums. Can be solved with sliding window OR prefix sums. For sliding window approach, shift thinking to use "AT MOST K" because this can be solved with sliding window. Then do AT MOST K - AT MOST K - 1.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |Concept: 1) Sliding window of dynamic size. 2) Count subarrays with non-contiguous constraint of EXACTLY k items.                                                                                                                                                                                                                                                              |
|Array / Hash Map / Sliding Window      |H      |[](https://leetcode.com/problems/subarrays-with-k-different-integers/description/)[992](https://leetcode.com/problems/subarrays-with-k-different-integers/description/)                                         |                                                                                                                                                                                                                                                                                    |Subarrays with K Different Integers                      |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |Concept: 1) Cannot converge to constraint based on window size. 2) Get (count of subarrays with AT MOST k) - (count of subarrays with AT MOST k - 1) to get count of subarrays with k.                                                                                                                                                                                         |
|Dynamic: Count Contiguous Subs         |:lemon:|                                                                                                                                                                                                                |                                                                                                                                                                                                                                                                                    |                                                         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |                                                                                                                                                                                                                                                                                                                                                                               |
|Array / Sliding Window                 |M      |[](https://leetcode.com/problems/number-of-zero-filled-subarrays/description/)[2348](https://leetcode.com/problems/number-of-zero-filled-subarrays/description/)                                                |                                                                                                                                                                                                                                                                                    |Number of Zero-Filled Subarrays                          |Good problem. Can use math equation to calculate number of problems given a subarray length.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |Concept: 1) Dynamic-size contiguous element sliding window. 2) Count subarrays using formula n \* (n + 1) / 2. 3) If window constraint is broken (left and right values are not equal), update answer and update left index to right index + 1.                                                                                                                                |
|String / Sliding Window                |M      |[](https://leetcode.com/problems/count-number-of-homogenous-substrings/)[1759](https://leetcode.com/problems/count-number-of-homogenous-substrings/)                                                            |[](https://github.com/BrandonKenter/Solutions/blob/main/Sliding%20Window/LC1759-countNumberOfHomogenousSubstrings.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Sliding%20Window/LC1759-countNumberOfHomogenousSubstrings.py)                                      |Count Number of Homogenous Substrings                    |This approach relies on knowing that you can calculate the number of substrings in a string of length n by doing 1 + 2 + 3 + â¦ n. So for each char, if is the same as all the others in the current substring, we can add the length of the current substring to the count. To understand how this works, think about the number of ways you can choose indices i and j when creating substrings with a double for loop. When i == j, we only have 1 way. When j = i + 1, we have two more ways, and for j = i + 2, we have 3 more ways and so on. Note: On the surface, this problem seems to be similar to LC 1358 - Number of Substrings Containing All Three Characters, but they are different in an important way. We know when we increase the substring length, the property we need (homogenous) is True for every substring. This is NOT the case for LC 1358, so we can't do the 1 + 2 + 3 ... approach.                                                                                                                                                                                                                                           |Concept: 1) Dynamic-size contiguous element sliding window. 2) Count subarrays using formula n \* (n + 1) / 2. 3) If window constraint is broken (left and right values are not equal), update answer and update left index to right index.                                                                                                                                    |

## Matrix

|2D Prefix Sums                                                                   |:lemon:|                                                                                                                                                                                                      |                                                                                                                                                                                                                                                                    |                                                  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |                                                                                                                                                                                                                                                                                                     |
|---------------------------------------------------------------------------------|-------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|Matrix / Prefix                                                                  |M      |[](https://leetcode.com/problems/range-sum-query-2d-immutable/)[304](https://leetcode.com/problems/range-sum-query-2d-immutable/)                                                                     |                                                                                                                                                                                                                                                                    |Range Sum Query 2D - Immutable                    |Similar to LC 1314                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |Concept: 1) Use 2D prefix sums to calculate range sums from each cell.                                                                                                                                                                                                                               |
|Trivial Search                                                                   |:lemon:|                                                                                                                                                                                                      |                                                                                                                                                                                                                                                                    |                                                  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |                                                                                                                                                                                                                                                                                                     |
|Matrix / Hash Set / Queue / Depth-First Search / Breadth-First Search / Recursion|E      |[](https://leetcode.com/problems/flood-fill/)[733](https://leetcode.com/problems/flood-fill/)                                                                                                         |[](https://github.com/BrandonKenter/Solutions/blob/main/Matrix/LC733-floodFill.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Matrix/LC733-floodFill.py)                                                                                            |Flood Fill                                        |You don't need a visited set because changing the cells as we go means we will never try to visit that cell again anyway. A reasonable question to have with these DFS/BFS problems is: which one to use? The answer is always: it depends. But, for this problem the only thing to worry about is the size of the grid. DFS uses stack space and stack space is limited. But we see in the problem constraints for this problem, the grid can be no bigger than 50x50. So DFS will not run into stack frame limitations.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |Concept: 1) DFS. 2) BFS. 3) Change matrix during DFS/BFS traversal.                                                                                                                                                                                                                                  |
|Matrix / Hash Set / Queue / Depth-First Search / Breadth-First Search / Recursion|M      |[](https://leetcode.com/problems/number-of-enclaves/)[1020](https://leetcode.com/problems/number-of-enclaves/)                                                                                        |[](https://github.com/BrandonKenter/Solutions/blob/main/Matrix/LC1020-numberOfEnclaves.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Matrix/LC1020-numberOfEnclaves.py)                                                                            |Number of Enclaves                                |To think about this problem in a different way, we can try to find all cells that are connected to the boundary and then not include those in our enclave count. This is why we search from the boundary cells only. There are many other ways to solve the problem, but this is a pretty clean way. Similar to LC 130.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |Concept: 1) Depth-First Search. 2) Breadth-First search. 3) Capture (traverse and add to visited) some cells and then do a separate traversal on the remaining unvisited cells.                                                                                                                      |
|Matrix                                                                           |M      |[](https://leetcode.com/problems/queens-that-can-attack-the-king/description/)[1222](https://leetcode.com/problems/queens-that-can-attack-the-king/description/)                                      |[](https://github.com/BrandonKenter/Solutions/blob/main/Matrix/LC1222-queensThatCanAttackTheKing.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Matrix/LC1222-queensThatCanAttackTheKing.py)                                                        |Queens That Can Attack the King                   |This is a good problem to be made aware of and practice 8-directional grid movement. Using a directions array is the cleanest way to do this. Also using a helper function for doing the search for each direction helps clean up the code.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |Concept: 1) 8-directional movement.                                                                                                                                                                                                                                                                  |
|Matrix / Hash Set / Queue / Depth-First Search / Breadth-First Search / Recursion|M      |[](https://leetcode.com/problems/maximum-number-of-fish-in-a-grid/)[2658](https://leetcode.com/problems/maximum-number-of-fish-in-a-grid/)                                                            |[](https://github.com/BrandonKenter/Solutions/blob/main/Matrix/LC2658-maximumNumberOfFishInAGrid.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Matrix/LC2658-maximumNumberOfFishInAGrid.py)                                                        |Maximum Number of Fish in a Grid                  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |Concept: 1) DFS. 2) BFS. 3) Sum of maximum path.                                                                                                                                                                                                                                                     |
|Matrix / Hash Set / Queue / Depth-First Search / Breadth-First Search / Recursion|M      |[](https://leetcode.com/problems/max-area-of-island/)[695](https://leetcode.com/problems/max-area-of-island/)                                                                                         |[](https://github.com/BrandonKenter/Solutions/blob/main/Matrix/LC695-maxAreaOfIsland.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Matrix/LC695-maxAreaOfIsland.py)                                                                                |Max Area of Island                                |For the cur_sum += dfs(nei_r, nei_c), think of the last call. The cur_sum will be 1 but will have no neighbors, so it will return 1. The previous call will have a cur_sum of 1 and will be adding the return value of 1 from the other DFS, so now cur_sum is 2. It's like a tree. We are adding one to our caller, and it keeps doing that until it gets back to the root. This is how the cur_sum is added.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |Concept: 1) DFS. 2) BFS. 3) Getting size of a search.                                                                                                                                                                                                                                                |
|Multisource BFS                                                                  |:lemon:|                                                                                                                                                                                                      |                                                                                                                                                                                                                                                                    |                                                  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |                                                                                                                                                                                                                                                                                                     |
|Matrix / Hash Set / Queue / Breadth-First Search                                 |M      |[](https://leetcode.com/problems/rotting-oranges/)[994](https://leetcode.com/problems/rotting-oranges/)                                                                                               |[](https://github.com/BrandonKenter/Solutions/blob/main/Matrix/LC994-rottingOranges.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Matrix/LC994-rottingOranges.py)                                                                                  |Rotting Oranges                                   |We are traversing the grid, which immediately brings you to think DFS or BFS as they are the two grid/graph traversal algorithms that cover most gird/graph traversal problems. But why do we go with BFS? Because of the nature of the traversal. At every time increment, we want to change everything around the oranges that were rotted last. This is a blatant traversal in a breadth-first manner. Treating every level of the BFS traversal as 1 minute makes this problem easy to understand as far as how to approach it with code.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |Concept: 1) Multi-source BFS.                                                                                                                                                                                                                                                                        |
|Matrix / Hash Set / Queue / Breadth-First Search / Shortest Path                 |M      |[](https://leetcode.com/problems/01-matrix/)[542](https://leetcode.com/problems/01-matrix/)                                                                                                           |[](https://github.com/BrandonKenter/Solutions/blob/main/Matrix/LC542-O1Matrix.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Matrix/LC542-O1Matrix.py)                                                                                              |01 Matrix                                         |"Distance to multiple cells" problems like this problem and LC 286 "Walls and Gates" can be solved by using the cells we want to reach as the source nodes for a multi-source BFS. If you think about it logically with a level-by-level traversal, it makes sense because at the destination cells it takes a distance of 0 to get to them. Then we can expand outward using BFS, add 1 to the distance and so on. Whereas if you start from any random cell, it isn't guaranteed that starting at this cell will produce an optimal path to a target. But starting from the target will ensure it is taking the optimal path backward.                                                                                                                                                                                                                                                                                                                                                                                                                                              |Concept: 1) If asked to find distance to nearest y thing from x, always flip thinking to go from x to y. Meaning change the target to the source. The reason we do this is because it's easier to assign distances this way. This approach becomes even more relevant in the Walls and Gates problem.|
|Matrix / Hash Set / Queue / Breadth-First Search / Shortest Path                 |M      |[](https://leetcode.com/problems/nearest-exit-from-entrance-in-maze/)[1926](https://leetcode.com/problems/nearest-exit-from-entrance-in-maze/)                                                        |[](https://github.com/BrandonKenter/Solutions/blob/main/Matrix/LC1926-nearestExitFromEntranceInMaze.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Matrix/LC1926-nearestExitFromEntranceInMaze.py)                                                  |Nearest Exit from Entrance in Maze                |Seeding the queue and visited sets is kind of ugly using indexing, so you can unpack the entrance list into two variables and create a tuple to make it a bit cleaner. For the check if the current cell is not the entrance, a clean way to write this is [r, c] != entrance.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |Concept: 1) BFS. 2) Shortest path in a matrix with obstacles.                                                                                                                                                                                                                                        |
|Unweighted Shortest Path                                                         |:lemon:|                                                                                                                                                                                                      |                                                                                                                                                                                                                                                                    |                                                  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |                                                                                                                                                                                                                                                                                                     |
|Matrix / Hash Set / Queue / Breadth-First Search / Shortest Path                 |M      |[](https://leetcode.com/problems/shortest-path-in-binary-matrix/)[1091](https://leetcode.com/problems/shortest-path-in-binary-matrix/)                                                                |[](https://github.com/BrandonKenter/Solutions/blob/main/Graph%20Traversal/LC1091-shortestPathinBinaryMatrix.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Graph%20Traversal/LC1091-shortestPathinBinaryMatrix.py)                                  |Shortest Path in Binary Matrix                    |Why do we use a standard BFS over Dijkstra's here, specifically using a queue instead of a min heap? Because the weights are constant (the cost to go between all adjacent cells is always 1). Can we still use Dijkstra's? Yes, but it is overkill as we don't need a priority queue because every distance to neighboring cells at each level is the same, so we don't need the sorted property of a min heap, so appending to and popping from a queue will be faster than adding to and removing from a min heap. But what if we need to keep track of shortest paths to each node? You can just declare a distances array like Dijkstra's does and add the distance to the repsective location in the array when it is first seen (again, it will never be updated after it is seen for the first time). One thing we lose from Dijkstra's that we need to add is visited checking logic. With Dijkstra's you check if the new path is shorter than old path, which with constant weight problems acts like a visited check, so with standard BFS make sure to use a visited set.|Concept: 1) Shorest path in a matrix with constant weights (BFS).                                                                                                                                                                                                                                    |
|Matrix / Hash Set / Queue / Breadth-First Search / Shortest Path                 |H      |[](https://leetcode.com/problems/shortest-path-in-a-grid-with-obstacles-elimination/description/)[1293](https://leetcode.com/problems/shortest-path-in-a-grid-with-obstacles-elimination/description/)|[](https://github.com/BrandonKenter/Solutions/blob/main/Graph/LC1293-shortestPathInAGridWithObstacles.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Graph/LC1293-shortestPathInAGridWithObstacles.py)                                              |Shortest Path in a Grid with Obstacles Elimination|Since each traversal from cell to cell is unweighted, we use BFS. Since each path will have its own choices of removing obstacles, we encode the current obstacles removed in each queue element.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |Concept: 1) Shortest path in a matrix with obstacles and unweighted edges using BFS.                                                                                                                                                                                                                 |
|Weighted Shortest Path                                                           |:lemon:|                                                                                                                                                                                                      |                                                                                                                                                                                                                                                                    |                                                  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |                                                                                                                                                                                                                                                                                                     |
|Matrix / Heap / Shortest Path                                                    |M      |[](https://leetcode.com/problems/path-with-minimum-effort/)[1631](https://leetcode.com/problems/path-with-minimum-effort/)                                                                            |[](https://github.com/BrandonKenter/Solutions/blob/main/Matrix/LC1631-pathWithMinimumEffort.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Matrix/LC1631-pathWithMinimumEffort.py)                                                                  |Path With Minimum Effort                          |When you pop an entry from the min heap that is the destination cell, you will always have the minimum path value up until this cell and you will only find larger paths if you keep checking for shorter paths. This is because we are optimally choosing a path up until this point due to the priority queue.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |Concept: 1) Dijkstra's on a matrix .                                                                                                                                                                                                                                                                 |
|Matrix / Heap / Shortest Path                                                    |H      |[](https://leetcode.com/problems/minimum-time-to-visit-a-cell-in-a-grid/description/)[2577](https://leetcode.com/problems/minimum-time-to-visit-a-cell-in-a-grid/description/)                        |                                                                                                                                                                                                                                                                    |Minimum Time to Visit a Cell In a Grid            |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |Concept: 1) Dijkstra's on a matrix .                                                                                                                                                                                                                                                                 |
|Matrix / Heap / Shortest Path                                                    |H      |[](https://leetcode.com/problems/swim-in-rising-water/)[778](https://leetcode.com/problems/swim-in-rising-water/)                                                                                     |[](https://github.com/BrandonKenter/Solutions/blob/main/Graph%20Traversal/Shortest%20Path/Dijkstra's/LC778-swimInRisingWater.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Graph%20Traversal/Shortest%20Path/Dijkstra's/LC778-swimInRisingWater.py)|Swim in Rising Water                              |An easier way to think about the problem is just as a shortest path problem since you can travel infinite distance in one iteration. But the shortest path for this problem is the shortest max height of all paths to the ending cell. This means we try to minimize the tallest cell we need to traverse. So for each iteration that would be the distance of a path in a 'regular' Dijkstra's problem is actually the max of all cells along the current path. We calculate this with 'nei_time = max(time, grid[nei_row][nei_col]). The times array acts both as a visited set and a record for the shortest max height to each cell. Keep in mind that we put the time as the first element in our pairs for the min heap because we want the min heap to pop pairs with the shortest current max.                                                                                                                                                                                                                                                                               |                                                                                                                                                                                                                                                                                                     |
|Column-wise Traversal                                                            |:lemon:|                                                                                                                                                                                                      |                                                                                                                                                                                                                                                                    |                                                  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |                                                                                                                                                                                                                                                                                                     |
|Matrix                                                                           |E      |[](https://leetcode.com/problems/find-the-width-of-columns-of-a-grid/description/)[2639](https://leetcode.com/problems/find-the-width-of-columns-of-a-grid/description/)                              |[](https://github.com/BrandonKenter/Solutions/blob/main/Matrix/LC2639-findTheWidthOfColumnsOfAGrid.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Matrix/LC2639-findTheWidthOfColumnsOfAGrid.py)                                                    |Find the Width of Columns of a Grid               |The naÃ¯ve approach would be to traverse the matrix row-wise and store the max for each column and update the max and min at each cell. This uses extra space. We can traverse the matrix column-wise and just keep track of the max length for the current row.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |Concept: 1) Traverse a grid column-wise instead of row-wise.                                                                                                                                                                                                                                         |
|Diagonals                                                                        |:lemon:|                                                                                                                                                                                                      |                                                                                                                                                                                                                                                                    |                                                  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |                                                                                                                                                                                                                                                                                                     |
|Matrix                                                                           |E      |[](https://leetcode.com/problems/check-if-matrix-is-x-matrix/description/)[2319](https://leetcode.com/problems/check-if-matrix-is-x-matrix/description/)                                              |[](https://github.com/BrandonKenter/Solutions/blob/main/Matrix/LC2319-checkIfMatrixIsX-Matrix.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Matrix/LC2319-checkIfMatrixIsX-Matrix.py)                                                              |Check if Matrix is X-Matrix                       |To check if grid[r][c] is on the negative diagonal, check if r + c == n - 1. To check if grid[r][c] is on the positive diagonal, check if r == c.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |Concept: 1) Use row and column indices to check if cell is a part of positive or negative diagonal.                                                                                                                                                                                                  |
|Matrix / Hash Map / Heap                                                         |M      |[](https://leetcode.com/problems/sort-the-matrix-diagonally/)[1329](https://leetcode.com/problems/sort-the-matrix-diagonally/)                                                                        |[](https://github.com/BrandonKenter/Solutions/blob/main/Matrix/LC1329-sortTheMatrixDiagonally.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Matrix/LC1329-sortTheMatrixDiagonally.py)                                                              |Sort the Matrix Diagonally                        |An important concept for this problem is being able to uniquely identify each diagonal. For this problem, we are asked for the primary diagonal (top left to bottom right). Each cell in its respective diagonal have the same result for its row index subtracted by its column index. So we can have a defaultdict of lists and append the cell's value to the list by doing diagonals[row-col].append(matrix[row][col]). This accesses the row-col diagonal and appends the value at the cell to its diagonal list.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |Concept: 1) Row - column index is how to uniquely identify each negative diagonal of a matrix.                                                                                                                                                                                                       |
|Hash Map                                                                         |:lemon:|                                                                                                                                                                                                      |                                                                                                                                                                                                                                                                    |                                                  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |                                                                                                                                                                                                                                                                                                     |
|Matrix / Hash Map                                                                |M      |[](https://leetcode.com/problems/equal-row-and-column-pairs/description/)[2352](https://leetcode.com/problems/equal-row-and-column-pairs/description/)                                                |[](https://github.com/BrandonKenter/Solutions/blob/main/Hash%20Map/LC2352-equalRowAndColumnPairs.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Hash%20Map/LC2352-equalRowAndColumnPairs.py)                                                        |Equal Row and Column Pairs                        |Using a hash map or hash set to record all the rows (make sure to use tuples since arrays cannot be hashed) allows us to then check the columns, and if the column tuple is present in the hash map/hash set, add it to the total.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |Concept: 1) Use a hash map to store a tuple of each row. 2) Check if the tuple of each column is in the row hash map.                                                                                                                                                                                |
|Hash Set                                                                         |:lemon:|                                                                                                                                                                                                      |                                                                                                                                                                                                                                                                    |                                                  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |                                                                                                                                                                                                                                                                                                     |
|Matrix / Hash Set                                                                |E      |[](https://leetcode.com/problems/check-if-every-row-and-column-contains-all-numbers/description/)[2133](https://leetcode.com/problems/check-if-every-row-and-column-contains-all-numbers/description/)|[](https://github.com/BrandonKenter/Solutions/blob/main/Hash%20Map/LC2133-checkIfEveryRowAndColumnContainsAllNumbers.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Hash%20Map/LC2133-checkIfEveryRowAndColumnContainsAllNumbers.py)                |Check if Every Row and Column Contains All Numbers|The O(1) approach is to mark corresponding row/col negative and check if its already negative                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |Concept: 1) Use a hash set for rows and columns to determine if each row and column contains all the numbers.                                                                                                                                                                                        |
|Matrix / Hash Set                                                                |M      |[](https://leetcode.com/problems/valid-sudoku/)[36](https://leetcode.com/problems/valid-sudoku/)                                                                                                      |[](https://github.com/BrandonKenter/Solutions/blob/main/Hash%20Map/LC36-validSudoku.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Hash%20Map/LC36-validSudoku.py)                                                                                  |Valid Sudoku                                      |The goal isn't to solve the sudoku board, just make sure that every entry is valid. The only complicated part of the algorithm is the mapping of a cell to a 3x3 square. If it isn't immediately obvious why dividing the row/col by 3 translates to the correct row/col, I recommend trying some examples to convince yourself.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |Concept: 1) Use a hash map for the rows, columns and squares of a matrix where the key is the row, column or (row, column) pair for the rows, columns and squares hash maps respectively.                                                                                                            |
|Trie                                                                             |:lemon:|                                                                                                                                                                                                      |                                                                                                                                                                                                                                                                    |                                                  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |                                                                                                                                                                                                                                                                                                     |
|Trie / Backtracking                                                              |H      |[](https://leetcode.com/problems/word-search-ii/)[212](https://leetcode.com/problems/word-search-ii/)                                                                                                 |[](https://github.com/BrandonKenter/Solutions/blob/main/Backtracking/LC212-wordSearchII.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Backtracking/LC212-wordSearchII.py)                                                                          |Word Search II                                    |Without using a Trie, we would have to essentially run LC 79's algorithm for each word in words. But with a Trie, we only have to run a similar time complexity solution once. IMPORTANT NOTE: My solution TLEs in LeetCode. There are some optimizations that can be made to it that will make it pass the more demanding test cases. The reason I omitted these optimizations is because it takes away from being able to develop pattern recognition and this solution will 100% be accepted in an interview.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |                                                                                                                                                                                                                                                                                                     |
|Misc                                                                             |:lemon:|                                                                                                                                                                                                      |                                                                                                                                                                                                                                                                    |                                                  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |                                                                                                                                                                                                                                                                                                     |
|Matrix / Math                                                                    |E      |[](https://leetcode.com/problems/shift-2d-grid/)[1260](https://leetcode.com/problems/shift-2d-grid/)                                                                                                  |[](https://github.com/BrandonKenter/Solutions/blob/main/Matrix/LC1260-shift2DGrid.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Matrix/LC1260-shift2DGrid.py)                                                                                      |Shift 2D Grid                                     |The trick for this problem is to convert every row-column to an index. This index would be the index if you traversed the array from top-left to bottom-right traversing in a left to right manner. The index is just the row number \* length of each column + the column number + k shifts. We then modulo this by (m \* n) because the index could be out of bounds, so we want to wrap it back around starting from the top-left. Getting the new row from the index is just dividing it by the number of rows, while getting the new col from the index is just moding it by n.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |Concept: 1) Convert each row/column pair to an index, increment the index, then revert back to a row/column pair to shift a matrix cell's value.                                                                                                                                                     |
|Matrix                                                                           |M      |[](https://leetcode.com/problems/rotate-image/)[48](https://leetcode.com/problems/rotate-image/)                                                                                                      |[](https://github.com/BrandonKenter/Solutions/blob/main/Matrix/LC48-rotateImage.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Matrix/LC48-rotateImage.py)                                                                                          |Rotate Image                                      |Beyond the complexity of off-by-one errors and traversing the array in a spiral order correctly, a tricky part of the problem is dealing with overwriting of values. To save us from dealing with complex tmp logic, just save the top left value in a variable and start the overwriting of cells by putting the bottom left into top left, bottom right into bottom left and so on (counter-clockwise).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |Concept: 1) Rotate matrix.                                                                                                                                                                                                                                                                           |
|Matrix                                                                           |M      |[](https://leetcode.com/problems/spiral-matrix/)[54](https://leetcode.com/problems/spiral-matrix/)                                                                                                    |[](https://github.com/BrandonKenter/Solutions/blob/main/Matrix/LC54-spiralMatrix.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Matrix/LC54-spiralMatrix.py)                                                                                        |Spiral Matrix                                     |Use four pointers: left, right, top and bottom. Iterate from left to right, top to bottom, right to left and bottom to top. After each iteration, increment/decrement the respective pointer. After the first two for loops, we have to check if left > right or top > bottom because one of them could have crossed the other at this point.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |Concept: 1) Traversing a matrix in a spiral order.                                                                                                                                                                                                                                                   |

## Math

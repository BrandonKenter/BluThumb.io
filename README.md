<p align="center">
    <h3 align="center">BluThumb.io     
 </h3>

  <p align="center">
    An all-in-one platform that facilitates reviewing LeetCode problems with spaced repetition.
    <br>
    <a href="https://bluthumb.io/"><strong>Check it out here Â»</strong></a>
  </p>
</p>

![portfolio-preview](https://github.com/BrandonKenter/BluThumb.io/blob/main/bluthumb-preview2.png)


## The purpose of this repo

BluThumb.io hosts a curated list of 300 problems called BluThumb 300. This list of problems was selected from a collection of notes I wrote for over 1000 LeetCode problems. As abundantly described on BluThumb.io, breaking down the common patterns into subpatterns allows us to create a better mental model for seeing new problems, identifying possible approaches, and arriving at a solution. Below is a breakdown of all the problems in BluThumb 300, with some notes accompanying most problems.

Click the README.md to see all 300 problems.

## Tree
|Pre-order Traversal                                                              |:lemon:|                                                                                                                                                                                           |                                                                                                                                                                                                                                                      |                                                         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |                                                                                                                                                                                                                                                                                            |
|---------------------------------------------------------------------------------|-------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|Tree / Binary Tree / Depth-First Search / Recursion                              |E      |[](https://leetcode.com/problems/binary-tree-preorder-traversal/)[144](https://leetcode.com/problems/binary-tree-preorder-traversal/)                                                      |[](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC144-binaryTreePreorderTraversal.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC144-binaryTreePreorderTraversal.py)                                              |Binary Tree Preorder Traversal                           |Preorder traversal traverses the tree structure in this order: Root -> Left -> Right. One aspect of preorder/inorder/postorder traversal that might not be immediately obvious is we are processing subtrees in the same order as a parent-children subtree. So from the root we process the root and then the whole left subtree then the whole right subtree. And also at a leaf node we process the leaf, then the left child, then the right child. This understanding is important for many problems that require you to do/calculate something from each subtree.                                                                                                                                                                                                                                                                                                                             |Concept: 1) Use preorder traversal to print the nodes in a preorder fashion.                                                                                                                                                                                                                |
|Tree / N-ary Tree / Depth-First Search / Recursion                               |E      |[](https://leetcode.com/problems/n-ary-tree-preorder-traversal/)[589](https://leetcode.com/problems/n-ary-tree-preorder-traversal/)                                                        |[](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC589-N-aryTreePreorderTraversal.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC589-N-aryTreePreorderTraversal.py)                                                |N-ary Tree Preorder Traversal                            |The space complexity is dependent on what someone considers to be extra space. Some people say data structures that store the output values are considered a part of the space complexity, while others don't. If the output array is counted, it is O(N) space copmlexity. If not, it is O(H) where H is the height of the tree (for the call stack). If an iterate BFS is done, it's always O(N) because the max size of the level in the BFS will have about N nodes in the queue. These tradeoffs are important to understand and should be able to be articulated in an interview.                                                                                                                                                                                                                                                                                                             |Concept: 1) Use pre-order traversal to traverse an n-ary tree.                                                                                                                                                                                                                              |
|Tree / Binary Tree / Depth-First Search / Recursion                              |E      |[](https://leetcode.com/problems/merge-two-binary-trees/)[617](https://leetcode.com/problems/merge-two-binary-trees/)                                                                      |                                                                                                                                                                                                                                                      |Merge Two Binary Trees                                   |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |Concept: 1) Preorder traversal. 2) Traverse two trees at the same time in the same positions even if one tree does not have a node in this position.                                                                                                                                        |
|Tree / Binary Tree / Depth-First Search / Recursion                              |E      |[](https://leetcode.com/problems/same-tree/)[100](https://leetcode.com/problems/same-tree/)                                                                                                |[](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC100-sameTree.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC100-sameTree.py)                                                                                    |Same Tree                                                |We might prefer the iterative DFS or BFS approach over the recursive DFS approach if stack space is an issue. Otherwise, the recursive DFS implementation Is way more clean and concise. If the tree is height-balanced, space complexity is O(logn) for the call stack of the DFS implementation. It is worth noting that I almost always omit iterative DFS solutions from explanations because the translation is trivial in most cases.                                                                                                                                                                                                                                                                                                                                                                                                                                                         |Concept: 1) Use preorder traversal on two trees simultaneously, comparing the node values at each node. 2) Use boolean evaluation.                                                                                                                                                          |
|Tree / Binary Tree / Depth-First Search / Recursion                              |M      |[](https://leetcode.com/problems/count-good-nodes-in-binary-tree/)[1448](https://leetcode.com/problems/count-good-nodes-in-binary-tree/)                                                   |[](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC1448-countGoodNodesInBinaryTree.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC1448-countGoodNodesInBinaryTree.py)                                              |Count Good Nodes in Binary Tree                          |This is a standard DFS traversal problem of a tree with a subpattern of keeping track of a count outside of the nested function and returning nothing from the DFS. It is a preorder traversal because we process the current node, then dfs on left then dfs on right. Notice how path_max is passed by value, so each execution context gets its own copy of path_max.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |Concept: 1) Use pre-order traversal to evaluate if the path to the current node has no nodes with a value greater than it.                                                                                                                                                                  |
|Tree / Binary Tree / Depth-First Search                                          |E      |[](https://leetcode.com/problems/binary-tree-paths/)[257](https://leetcode.com/problems/binary-tree-paths/)                                                                                |[](https://github.com/BrandonKenter/Solutions/blob/main/Tree/binaryTreePaths.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/binaryTreePaths.py)                                                                                  |Binary Tree Paths                                        |Cur_path is a list so in python it is passed by reference. This means that every execution context for each recursive call gets a reference to the same list. So when the call stack pops back up, we are still pointing ot the list that has that extra node in it. So we pop from cur_path to make sure each execution context has the corresponding path. The space complexity O(H) is for the call stack. If we consider the output array paths, then it would be closer to O(N\*H) since there can be about N paths of height H.                                                                                                                                                                                                                                                                                                                                                               |Concept: 1) Use preorder traversal to print each root to leaf path. 2) Build the current path using a list parameter and preorder traversal (add to path first, then check if this node is a leaf). 3) Check if node is a leaf node.                                                        |
|In-order Traversal                                                               |:lemon:|                                                                                                                                                                                           |                                                                                                                                                                                                                                                      |                                                         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |                                                                                                                                                                                                                                                                                            |
|Tree / Binary Tree / Depth-First Search / Recursion                              |E      |[](https://leetcode.com/problems/binary-tree-inorder-traversal/)[94](https://leetcode.com/problems/binary-tree-inorder-traversal/)                                                         |[](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC94-binaryTreeInorderTraversal.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC94-binaryTreeInorderTraversal.py)                                                  |Binary Tree Inorder Traversal                            |Inorder traversal traverses a tree structure in a Left -> Root -> Right sequence. The code might be hard to trace if you are not familiar with recursion. The visual of the code doesn't really reflect what is happening during program execution. I recommend watching a video that goes through the traversal if you are not able to visualize each step of the traversal.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |Concept: 1) Use in-order traversal to print the nodes in an in-order fashion.                                                                                                                                                                                                               |
|Tree / Binary Tree / Depth-First Search / Recursion                              |E      |[](https://leetcode.com/problems/minimum-distance-between-bst-nodes/)[783](https://leetcode.com/problems/minimum-distance-between-bst-nodes/)                                              |[](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC783-minimumDistanceBetweenBSTNodes.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC783-minimumDistanceBetweenBSTNodes.py)                                        |Minimum Distance Between BST Nodes                       |The reason we do an inorder traversal is because the minimum difference between two nodes will always be between two nodes that are adjacent in sorted order. This similar to LC 285, but we are checking all successors, so a full inorder traversal is necessary. The reason we use a nonlocal variable outside of the dfs function is because the adjacent values aren't always directly connected by one edge, so we can't use something like a parent reference and must keep track of the last evaluated node. Think of how inorder works. Left -> Root -> Right. So it goes deep left, processes left, processes root, then processes right. The next value in the inorder traversal if there a more nodes in the tree is right's parent's parent, since right is in the left subtree of the Left -> Root -> Right traversal.                                                                |Concept: 1) Use in-order traversal with a nonlocal variable tracking the previous node's value to find the minimum difference between two nodes.                                                                                                                                            |
|Tree / Binary Tree / Depth-First Search / Recursion                              |M      |[](https://leetcode.com/problems/binary-search-tree-iterator/)[173](https://leetcode.com/problems/binary-search-tree-iterator/)                                                            |[](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC173-binarySearchTreeIterator.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC173-binarySearchTreeIterator.py)                                                    |Binary Search Tree Iterator                              |To suspend the iterator on the next node, use a stack and populate it with all left nodes until we reach a null node. Then when next() is called, popping the node at the top of the stack will be the next node in the iterator. Then get the node's right reference (if it is not None) and again traverse down to the left, adding each node to the stack. This acts like inorder DFS where we suspend the iterator at the next node.                                                                                                                                                                                                                                                                                                                                                                                                                                                            |Concept: 1) Use a stack to implement iterative in-order traversal.                                                                                                                                                                                                                          |
|Post-order Traversal                                                             |:lemon:|                                                                                                                                                                                           |                                                                                                                                                                                                                                                      |                                                         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |                                                                                                                                                                                                                                                                                            |
|Tree / Binary Tree / Depth-First Search / Recursion                              |E      |[](https://leetcode.com/problems/binary-tree-postorder-traversal/)[145](https://leetcode.com/problems/binary-tree-postorder-traversal/)                                                    |[](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC145-binaryTreePostorderTraversal.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC145-binaryTreePostorderTraversal.py)                                            |Binary Tree Postorder Traversal                          |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |Concept: 1) Use post-order traversal to print the nodes in a tree in a post-order fashion.                                                                                                                                                                                                  |
|Tree / Binary Tree / Depth-First Search / Recursion                              |E      |[](https://leetcode.com/problems/balanced-binary-tree/)[110](https://leetcode.com/problems/balanced-binary-tree/)                                                                          |[](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC110-balancedBinaryTree.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC110-balancedBinaryTree.py)                                                                |Balanced Binary Tree                                     |A somewhat tricky thing to come up with is returning a pair of values for each recursive call. Also note that this approach requires a helper function because isBalanced() returns a bool. So we can't use isBalanced() to pass the pair of values up the tree during recursion and eventually to the original caller which only wants a bool value.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |Concept: 1) Use post-order traversal to compare subtree heights.                                                                                                                                                                                                                            |
|Tree / Binary Tree / Depth-First Search / Recursion                              |M      |[](https://leetcode.com/problems/delete-leaves-with-a-given-value/description/)[1325](https://leetcode.com/problems/delete-leaves-with-a-given-value/description/)                         |[](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC1325-deleteLeavesWithAGivenValue.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC1325-deleteLeavesWithAGivenValue.py)                                            |Delete Leaves With a Given Value                         |Use a postorder traversal. We want postorder so we can remove references of leaf nodes that match the target value starting from the bottom and going up. Since we are reassigning references, we can recursively set root.left and root.right to the respective DFS calls. And since we are assigning infromation to each child, we must return some information. And that infromation is the children nodes. So we encode the case that we want to delete by returning None, which will in turn set root.left or root.right to None if they should be deleted. Otherwise, we return root. And the base case returns None if root is None because we want root.left/root.right to be assigned to None if there is no node.                                                                                                                                                                         |Concept: 1) Use post-order traversal to delete leaf nodes that match a target value. 2) Deleting a leaf node can make its parent a leaf node, making a bottom-up order beneficial.                                                                                                          |
|Tree / Binary Tree / Depth-First Search / Recursion                              |M      |[](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/)[236](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/)                                    |[](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC236-lowestCommonAncestorOfABinaryTree.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC236-lowestCommonAncestorOfABinaryTree.py)                                  |Lowest Common Ancestor of a Binary Tree                  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |Concept: 1) Use post-order traversal to find the LCA of two nodes.                                                                                                                                                                                                                          |
|Tree / Binary Tree / Depth-First Search / Recursion                              |M      |[](https://leetcode.com/problems/count-nodes-equal-to-average-of-subtree/)[2265](https://leetcode.com/problems/count-nodes-equal-to-average-of-subtree/)                                   |[](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC2265-countNodesEqualToAverageOfSubtree.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC2265-countNodesEqualToAverageOfSubtree.py)                                |Count Nodes Equal to Average of Subtree                  |This is a problem that follows the subpattern of processing nodes in a postorder manner. We recurse deeply on the left, then on the right, store whatever information we get from the left and right subtrees into variables, and then use the left and right subtree values we found to compute what the problem is asking for. Important things to note for these types of problems: 1) We return a value in the recursion (a pair of values in this case) even in the base case. 2) We do a preorder traversal and store the values returned by the left and right subtrees in variables 'left' and 'right'. 3) We do a computation on the information we found in the two subtrees. 4) We return a value in the recursion to this execution context's caller (a pair of values in this case).                                                                                                   |Concept: 1) use post-order traversal to find the average of the values of each node's left and right subtrees and compare it against the current node's value.                                                                                                                              |
|Tree / Binary Tree / Depth-First Search / Recursion                              |H      |[](https://leetcode.com/problems/binary-tree-maximum-path-sum/)[124](https://leetcode.com/problems/binary-tree-maximum-path-sum/)                                                          |[](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC124-binaryTreeMaximumPathSum.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC124-binaryTreeMaximumPathSum.py)                                                    |Binary Tree Maximum Path Sum                             |This is considered a postorder traversal because we traverse the left subtree, then right subtree, then we process the current. When returning in the DFS, we get max between cur, cur + left and cur + right because it's more explicit so it's easier to trace and understand, but the singular cur.val is not needed since negatives are changed to 0. If the tree is height-balanced, space complexity is O(logn) for the call stack.                                                                                                                                                                                                                                                                                                                                                                                                                                                           |Concept: 1) Use post-order traversal to find the maximum path sum that goes through every node and its subtrees.                                                                                                                                                                            |
|Level-order Traversal                                                            |:lemon:|                                                                                                                                                                                           |                                                                                                                                                                                                                                                      |                                                         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |                                                                                                                                                                                                                                                                                            |
|Tree / Binary Tree / Breadth-First Search / Recursion                            |M      |[](https://leetcode.com/problems/binary-tree-level-order-traversal/)[102](https://leetcode.com/problems/binary-tree-level-order-traversal/)                                                |[](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC102-binaryTreeLevelOrderTraversal.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC102-binaryTreeLevelOrderTraversal.py)                                          |Binary Tree Level Order Traversal                        |This is a standard BFS traversal on a tree. If you are asked to do some type of processing of a tree structure level-wise, it will always be a BFS traversal. It is nearly identical in form to doing a BFS on a graph.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |Concept: Use level-order traversal to traverse a binary tree.                                                                                                                                                                                                                               |
|Tree / N-ary Tree / Breadth-First Search / Recursion                             |M      |[](https://leetcode.com/problems/n-ary-tree-level-order-traversal/description/)[429](https://leetcode.com/problems/n-ary-tree-level-order-traversal/description/)                          |[](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC429-n-aryTreeLevelOrderTraversal.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC429-n-aryTreeLevelOrderTraversal.py)                                            |N-ary Tree Level Order Traversal                         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |Concept: Use level-order traversal to traverse an n-ary tree.                                                                                                                                                                                                                               |
|Tree / Binary Tree / Breadth-First Search / Recursion                            |M      |[](https://leetcode.com/problems/maximum-level-sum-of-a-binary-tree/)[1161](https://leetcode.com/problems/maximum-level-sum-of-a-binary-tree/)                                             |[](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC1161-maximumLevelSumOfBinaryTree.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC1161-maximumLevelSumOfBinaryTree.py)                                            |Maximum Level Sum of a Binary Tree                       |Make sure the level_sum > max_level_sum check is > not >= because we want the minimum level. If we update based on if they are equal too, we are then taking the maximum level.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |Concept: Use level-order traversal to traverse a binary tree, tracking the sum of all node values of each level.                                                                                                                                                                            |
|Vertical-order Traversal                                                         |:lemon:|                                                                                                                                                                                           |                                                                                                                                                                                                                                                      |                                                         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |                                                                                                                                                                                                                                                                                            |
|Tree / Binary Tree / Hash Map / Depth-First Search / Recursion                   |H      |[](https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/)[987](https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/)                                |[](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC987-verticalOrderTraversalOfABinaryTree.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC987-verticalOrderTraversalOfABinaryTree.py)                              |Vertical Order Traversal of a Binary Tree                |The time complexity comes from the sorting of the columns and the rows when creating the result array that we return. A difficult part of the problem (at least for me) is traversing the dictionary to get the result. Not often are you required to sort keys in a dictionary, so not having this knowledge might push you to a different approach entirely which might be harder to implement. This is why knowing the data structures in your language and how to manipulate them is very important.                                                                                                                                                                                                                                                                                                                                                                                            |Concept: 1) Get the vertical ordering of a binary tree by using a column-to-row mapping. Similar to LC 314.                                                                                                                                                                                 |
|Binary Search Tree                                                               |:lemon:|                                                                                                                                                                                           |                                                                                                                                                                                                                                                      |                                                         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |                                                                                                                                                                                                                                                                                            |
|Tree / Binary Search Tree / Depth-First Search / Recursion                       |E      |[](https://leetcode.com/problems/search-in-a-binary-search-tree/)[700](https://leetcode.com/problems/search-in-a-binary-search-tree/)                                                      |[](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC700-searchInABinarySearchTree.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC700-searchInABinarySearchTree.py)                                                  |Search in a Binary Search Tree                           |For time complexity, it is O(log(N)) if the tree is height-balanced and O(N) if it is not. Using the iterative traversal uses O(1) space because we do not need stack space for the function calls. As for recursion, the worst-case would be if the value we are looking for is a leaf node. No matter what, this scenario would yield a space complexity of O(H) due to the stack frames needed for each function call.                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |Concept: 1) Use binary search to find a target value in a binary search tree.                                                                                                                                                                                                               |
|Tree / Binary Search Tree / Depth-First Search / Recursion                       |M      |[](https://leetcode.com/problems/validate-binary-search-tree/)[98](https://leetcode.com/problems/validate-binary-search-tree/)                                                             |[](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC98-validateBinarySearchTree.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC98-validateBinarySearchTree.py)                                                      |Validate Binary Search Tree                              |All we have to do is keep a running minimum and maximum bound for each recursive call in the DFS as parameters, update them accordingly and check cur.val against them. To evaluate the boolean value of all subtrees, we need evaluate the left and right subtrees at each root. This is a very common subpattern of preorder traversal where we have a base case that returns a result and another case that acts as the processing part for the preorder traversal before dfs on left and right are called. Then we return left AND right, so True is only returned if all subtrees evaluate to True.                                                                                                                                                                                                                                                                                            |Concept: 1) Use preorder traversal to check if each node in a binary search tree is valid. 2) Use boolean evaluation for the return statement.                                                                                                                                              |
|Tree / Binary Search Tree / Depth-First Search / Recursion                       |M      |[](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/)[235](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/)                      |[](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC235-lowestCommonAncestorOfABinarySearchTree.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC235-lowestCommonAncestorOfABinarySearchTree.py)                      |Lowest Common Ancestor of a Binary Search Tree           |Different from finding LCA of a tree that does not have the BST property because we know the upper bound of values in the left subtree and the lower bound of values in the right subtree at each root node of each subtree.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |Concept: 1) Use the BST property to check what subtree a target value is in relation to the current value. 2) Lowest common ancestor.                                                                                                                                                       |
|Tree / Binary Search Tree / Depth-First Search / Recursion                       |M      |[](https://leetcode.com/problems/insert-into-a-binary-search-tree/)[701](https://leetcode.com/problems/insert-into-a-binary-search-tree/)                                                  |[](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC701-insertIntoABinarySearchTree.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC701-insertIntoABinarySearchTree.py)                                              |Insert into a Binary Search Tree                         |The idea for this algorithm is to greedily search for an insert position at a position at the bottom of the tree that will make it a leaf. For the recursive function, there is no need to return anything because we are just updating a reference. For the iterative approach, we can iterate while True because we are guaranteed to reach a leaf node. Both approaches greedily converge to an insert position and look ahead to see if the reference in the correct direction is None.                                                                                                                                                                                                                                                                                                                                                                                                         |Concept: 1) Use binary search to search for an insert position and insert a new node with a given value.                                                                                                                                                                                    |
|Tree / Binary Search Tree / Depth-First Search / Recursion                       |M      |[](https://leetcode.com/problems/convert-bst-to-greater-tree/)[538](https://leetcode.com/problems/convert-bst-to-greater-tree/)                                                            |[](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC538-convertBSTToGreaterTree.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC538-convertBSTToGreaterTree.py)                                                      |Convert BST to Greater Tree                              |This traversal is considered to be reverse inorder traversal. Inorder traversal is Left -> Root -> Right. Reverse inorder is Right -> Root -> Left. To explain why inorder and why reverse: The reason we do inorder traversal because inorder traversal of a BST processes each node in order from smallest to largest. (Keep in mind this is for a BST specifically). And the reason we do it in reverse order is because we want to process the nodes in order from largest to smallest according to the problem statement.                                                                                                                                                                                                                                                                                                                                                                      |Concept: 1) Use reverse in-order traversal to add the postfix sum of the sorted values to each node.                                                                                                                                                                                        |
|Construct Tree                                                                   |:lemon:|                                                                                                                                                                                           |                                                                                                                                                                                                                                                      |                                                         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |                                                                                                                                                                                                                                                                                            |
|Array / Tree / Binary Tree / Depth-First Search / Recursion                      |E      |[](https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/)[108](https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/)                              |[](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC108-convertSortedArrayToBST.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC108-convertSortedArrayToBST.py)                                                      |Convert Sorted Array to BST                              |We have to use the sorted property of the array along with the relationship between values in a binary search tree to solve the problem. For the root of every subtree in a binary search tree, all of the values in the left subtree are less than the root, while all of the values in the right subtree are greater than the root. Since we want a height-balanced tree, we want the left and right subtrees to be of similar height. So we pick the root to be the middle of the array. Then we set the left child and right child of this root as the middle of the left subarray and right subarray respectively. We will do this recursively. The base case is when nums is empty, we return None.                                                                                                                                                                                           |Concept: 1) Convert a sorted array to a binary search tree.                                                                                                                                                                                                                                 |
|Array / Tree / Binary Tree / Depth-First Search / Recursion                      |M      |[](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)[105](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)|[](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC105-constructBinaryTreeFromPreorderAndInorderTraversal.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC105-constructBinaryTreeFromPreorderAndInorderTraversal.py)|Construct Binary Tree from Preorder and Inorder Traversal|More explanation: The global 'preorder_index' is helpful because the preorder value is always the next value in the preorder array after a root is created. Root.left and root.right is fairly trivial now since we are only changing the bound respective to its side and we do not include the root value in each bound.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |Concept: 1) Convert a pre-order array and an in-order array into a binary tree.                                                                                                                                                                                                             |
|Tree / Binary Tree / Depth-First Search / Recursion                              |H      |[](https://leetcode.com/problems/serialize-and-deserialize-binary-tree/)[297](https://leetcode.com/problems/serialize-and-deserialize-binary-tree/)                                        |[](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC297-serializeAndDeserializeBinaryTree.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC297-serializeAndDeserializeBinaryTree.py)                                  |Serialize and Deserialize Binary Tree                    |There are two main ways these functions can be implemented. With DFS and with BFS. I prefer BFS because I think it is way easier to visualize the construction of a tree through BFS. Serialize matches the type of BFS you normally see because it is being done on a tree structure, whereas deserialize is doing BFS on a string. In deserialize it really is just a matter of understanding how to traverse the array to create the nodes and update the references to left and right of each root node. I strongly recommend watching Striver's video (the first 7 minutes) to get a good visualization on how this translation between a tree structure and string is done.                                                                                                                                                                                                                   |Concept: 1) Serialize and deserialize a binary tree.                                                                                                                                                                                                                                        |
|Binary Tree Indices                                                              |:lemon:|                                                                                                                                                                                           |                                                                                                                                                                                                                                                      |                                                         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |                                                                                                                                                                                                                                                                                            |
|Tree / Binary Tree / Hash Set / Depth-First Search / Recursion                   |M      |[](https://leetcode.com/problems/find-elements-in-a-contaminated-binary-tree/description/)[1261](https://leetcode.com/problems/find-elements-in-a-contaminated-binary-tree/description/)   |[](https://github.com/BrandonKenter/Solutions/blob/main/Hash%20Map/LC1261-findElementsInAContaminatedBinaryTree.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Hash%20Map/LC1261-findElementsInAContaminatedBinaryTree.py)            |Find Elements in a Contaminated Binary Tree              |This is similar to problems where you need the index of a node in a tree. One of these other problems is LC 662 - "Maximum Width of Binary Tree". So once we notice that the values of each node in this problem are actually the indices, you just need to know the formulas for calculating them and then this problem becuase fairly trivial. The formulas for each index: Left child = cur val \* 2 + 1. Right child = cur val \* 2 + 2. These indices can be found either with BFS or DFS. Both implementations use a "self.values" set to store visited indices of nodes, which is important to make the find() function an O(1) lookup.                                                                                                                                                                                                                                                      |Concept: 1) Binary tree indices.                                                                                                                                                                                                                                                            |
|Tree / Binary Tree / Depth-First Search / Recursion                              |M      |[](https://leetcode.com/problems/check-completeness-of-a-binary-tree/description/)[958](https://leetcode.com/problems/check-completeness-of-a-binary-tree/description/)                    |[](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC958-checkCompletenessOfABinaryTree.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC958-checkCompletenessOfABinaryTree.py)                                        |Check Completeness of a Binary Tree                      |A helpful trick you can use with binary trees is to calculate the index of each node from top to bottom and left to right. To calculate the node's index in the tree, start the root node at index 0. Then when we call dfs on the children, the left child's index is 2\*i+1, while the right child's index is 2\*i+2. We can use these indices to check if the last node we saw on the last level is equal to the number of nodes seen - 1. To have access to the last node's index in the last level of the tree, update it when we are at the max height/depth of the tree so far. Since dfs traverses the tree left to right, this is guaranteed to be the rightmost node in the last level of the tree.                                                                                                                                                                                       |Concept: 1) Binary tree indices. 2) Complete binary tree definition.                                                                                                                                                                                                                        |
|Build Graph                                                                      |:lemon:|                                                                                                                                                                                           |                                                                                                                                                                                                                                                      |                                                         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |                                                                                                                                                                                                                                                                                            |
|Tree / Binary Tree / Graph / Breadth-First Search                                |M      |[](https://leetcode.com/problems/all-nodes-distance-k-in-binary-tree/)[863](https://leetcode.com/problems/all-nodes-distance-k-in-binary-tree/)                                            |[](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC863-allNodesDistanceKInBinaryTree.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC863-allNodesDistanceKInBinaryTree.py)                                          |All Nodes Distance K in Binary Tree                      |We need a visited hash set in the BFS because we have undirected edges in the new adjacency list. This is an important distinction between trees (no cycles) and undirected graphs (cycles). For populating the adjacency list, DFS is simpler and a better average time complexity (if tree is height-balanced because space complexity is O(log(N)) for the call stack instead of O(N) that the queue in BFS uses). For creating adj list with DFS, use cur and parent parameters and add undirected edge to adjacency list if cur and parent are not None. One thing to think about is how this way avoids duplicate edges. Imagine if you made an entry for left and right child at each DFS call.                                                                                                                                                                                              |Concept: 1) Convert tree to graph. 2) Use breadth-first search to find distance to target value.                                                                                                                                                                                            |
|Tree / N-ary Tree / Graph / Depth-First Search / Breadth-First Search / Recursion|M      |[](https://leetcode.com/problems/reachable-nodes-with-restrictions/description/)[2368](https://leetcode.com/problems/reachable-nodes-with-restrictions/description/)                       |[](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC2368-reachableNodesWithRestrictions.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC2368-reachableNodesWithRestrictions.py)                                      |Reachable Nodes With Restrictions                        |This is a standard DFS/BFS problem with a few extra complexities. The first complexity is checking if a node is restricted or not so we avoid going down this path. To do this efficiently, cast restricted to a set so we can do O(1) lookups for node values. The second complexity is the edges being undirected. Most tree problems provide a tree data structure with ListNodes that have directed edges (left and right typically), so you can only traverse the tree in one direction. But for this problem, we are only provided edges, and these edges are undirected. So when we start from 0 and go down the tree, we have to make sure we aren't going back up the tree and recounting nodes/going into an infinite loop. To avoid this, just use a prev reference for the parent node and make sure the neighbor node we are about to call DFS on isn't the parent of the current node.|Concept: 1) Convert tree to graph. 2) Using prev to avoid traversing already traversed nodes, while also avoiding traversing nodes that are restricted. 3) Know how to do this for DFS and BFS (use prev parameter in DFS method signature and use tuples of (cur, prev) as nodes in queue).|
|Node Relationships                                                               |:lemon:|                                                                                                                                                                                           |                                                                                                                                                                                                                                                      |                                                         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |                                                                                                                                                                                                                                                                                            |
|Tree / Binary Tree / Breadth-First Search / Recursion                            |E      |[](https://leetcode.com/problems/cousins-in-binary-tree/description/)[993](https://leetcode.com/problems/cousins-in-binary-tree/description/)                                              |                                                                                                                                                                                                                                                      |Cousins in Binary Tree                                   |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |Concept: 1) Cousins in a binary tree.                                                                                                                                                                                                                                                       |
|Tree / Binary Tree / Breadth-First Search / Recursion                            |M      |[](https://leetcode.com/problems/sum-of-nodes-with-even-valued-grandparent/)[1315](https://leetcode.com/problems/sum-of-nodes-with-even-valued-grandparent/)                               |[](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC1315-sumOfNodesWithEven-ValuedGrandparent.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC1315-sumOfNodesWithEven-ValuedGrandparent.py)                          |Sum of Nodes with Even-Valued Grandparent                |This implementation is an improvement on the slightly naÃ¯ve approach of storing a path array that holds state that describes each node as either even or odd. But this adds an extra O(H) space complexity. For a constant O(1) space complexity, we keep two variables 'parent' and 'grand' to keep track of the even/odd bool for each node's ancestors. A mistake I initially made is trying to update grand to parent before checking 'if grand' in the recursive procedure. We want update grand after 'if grand' because the code assumes parent and grand are already updated before this check.                                                                                                                                                                                                                                                                                             |Concept: 1) Grandparents in a binary tree.                                                                                                                                                                                                                                                  |

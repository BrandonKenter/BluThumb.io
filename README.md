<p align="center">
    <h3 align="center">BluThumb.io     
 </h3>

  <p align="center">
    An all-in-one platform that facilitates reviewing LeetCode problems with spaced repetition.
    <br>
    <a href="https://bluthumb.io/"><strong>Check it out here Â»</strong></a>
  </p>
</p>

![portfolio-preview](https://github.com/BrandonKenter/BluThumb.io/blob/main/bluthumb-preview2.png)


## The purpose of this repo

BluThumb.io hosts a curated list of 300 problems called BluThumb 300. This list of problems was selected from a collection of notes I wrote for over 1000 LeetCode problems. As abundantly described on BluThumb.io, breaking down the common patterns into subpatterns allows us to create a better mental model for seeing new problems, identifying possible approaches, and arriving at a solution. Below is a breakdown of all the problems in BluThumb 300, with some notes accompanying most problems.

Click the README.md to see all 300 problems.

## Tree

|Pre-order Traversal                                                              |:lemon:|                                                                                                                                                                                           |                                                                                                                                                                                                                                                      |                                                         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |                                                                                                                                                                                                                                                                                            |
|---------------------------------------------------------------------------------|-------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|Tree / Binary Tree / Depth-First Search / Recursion                              |E      |[](https://leetcode.com/problems/binary-tree-preorder-traversal/)[144](https://leetcode.com/problems/binary-tree-preorder-traversal/)                                                      |[](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC144-binaryTreePreorderTraversal.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC144-binaryTreePreorderTraversal.py)                                              |Binary Tree Preorder Traversal                           |Preorder traversal traverses the tree structure in this order: Root -> Left -> Right. One aspect of preorder/inorder/postorder traversal that might not be immediately obvious is we are processing subtrees in the same order as a parent-children subtree. So from the root we process the root and then the whole left subtree then the whole right subtree. And also at a leaf node we process the leaf, then the left child, then the right child. This understanding is important for many problems that require you to do/calculate something from each subtree.                                                                                                                                                                                                                                                                                                                             |Concept: 1) Use preorder traversal to print the nodes in a preorder fashion.                                                                                                                                                                                                                |
|Tree / N-ary Tree / Depth-First Search / Recursion                               |E      |[](https://leetcode.com/problems/n-ary-tree-preorder-traversal/)[589](https://leetcode.com/problems/n-ary-tree-preorder-traversal/)                                                        |[](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC589-N-aryTreePreorderTraversal.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC589-N-aryTreePreorderTraversal.py)                                                |N-ary Tree Preorder Traversal                            |The space complexity is dependent on what someone considers to be extra space. Some people say data structures that store the output values are considered a part of the space complexity, while others don't. If the output array is counted, it is O(N) space copmlexity. If not, it is O(H) where H is the height of the tree (for the call stack). If an iterate BFS is done, it's always O(N) because the max size of the level in the BFS will have about N nodes in the queue. These tradeoffs are important to understand and should be able to be articulated in an interview.                                                                                                                                                                                                                                                                                                             |Concept: 1) Use pre-order traversal to traverse an n-ary tree.                                                                                                                                                                                                                              |
|Tree / Binary Tree / Depth-First Search / Recursion                              |E      |[](https://leetcode.com/problems/merge-two-binary-trees/)[617](https://leetcode.com/problems/merge-two-binary-trees/)                                                                      |                                                                                                                                                                                                                                                      |Merge Two Binary Trees                                   |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |Concept: 1) Preorder traversal. 2) Traverse two trees at the same time in the same positions even if one tree does not have a node in this position.                                                                                                                                        |
|Tree / Binary Tree / Depth-First Search / Recursion                              |E      |[](https://leetcode.com/problems/same-tree/)[100](https://leetcode.com/problems/same-tree/)                                                                                                |[](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC100-sameTree.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC100-sameTree.py)                                                                                    |Same Tree                                                |We might prefer the iterative DFS or BFS approach over the recursive DFS approach if stack space is an issue. Otherwise, the recursive DFS implementation Is way more clean and concise. If the tree is height-balanced, space complexity is O(logn) for the call stack of the DFS implementation. It is worth noting that I almost always omit iterative DFS solutions from explanations because the translation is trivial in most cases.                                                                                                                                                                                                                                                                                                                                                                                                                                                         |Concept: 1) Use preorder traversal on two trees simultaneously, comparing the node values at each node. 2) Use boolean evaluation.                                                                                                                                                          |
|Tree / Binary Tree / Depth-First Search / Recursion                              |M      |[](https://leetcode.com/problems/count-good-nodes-in-binary-tree/)[1448](https://leetcode.com/problems/count-good-nodes-in-binary-tree/)                                                   |[](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC1448-countGoodNodesInBinaryTree.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC1448-countGoodNodesInBinaryTree.py)                                              |Count Good Nodes in Binary Tree                          |This is a standard DFS traversal problem of a tree with a subpattern of keeping track of a count outside of the nested function and returning nothing from the DFS. It is a preorder traversal because we process the current node, then dfs on left then dfs on right. Notice how path_max is passed by value, so each execution context gets its own copy of path_max.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |Concept: 1) Use pre-order traversal to evaluate if the path to the current node has no nodes with a value greater than it.                                                                                                                                                                  |
|Tree / Binary Tree / Depth-First Search                                          |E      |[](https://leetcode.com/problems/binary-tree-paths/)[257](https://leetcode.com/problems/binary-tree-paths/)                                                                                |[](https://github.com/BrandonKenter/Solutions/blob/main/Tree/binaryTreePaths.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/binaryTreePaths.py)                                                                                  |Binary Tree Paths                                        |Cur_path is a list so in python it is passed by reference. This means that every execution context for each recursive call gets a reference to the same list. So when the call stack pops back up, we are still pointing ot the list that has that extra node in it. So we pop from cur_path to make sure each execution context has the corresponding path. The space complexity O(H) is for the call stack. If we consider the output array paths, then it would be closer to O(N\*H) since there can be about N paths of height H.                                                                                                                                                                                                                                                                                                                                                               |Concept: 1) Use preorder traversal to print each root to leaf path. 2) Build the current path using a list parameter and preorder traversal (add to path first, then check if this node is a leaf). 3) Check if node is a leaf node.                                                        |
|In-order Traversal                                                               |:lemon:|                                                                                                                                                                                           |                                                                                                                                                                                                                                                      |                                                         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |                                                                                                                                                                                                                                                                                            |
|Tree / Binary Tree / Depth-First Search / Recursion                              |E      |[](https://leetcode.com/problems/binary-tree-inorder-traversal/)[94](https://leetcode.com/problems/binary-tree-inorder-traversal/)                                                         |[](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC94-binaryTreeInorderTraversal.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC94-binaryTreeInorderTraversal.py)                                                  |Binary Tree Inorder Traversal                            |Inorder traversal traverses a tree structure in a Left -> Root -> Right sequence. The code might be hard to trace if you are not familiar with recursion. The visual of the code doesn't really reflect what is happening during program execution. I recommend watching a video that goes through the traversal if you are not able to visualize each step of the traversal.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |Concept: 1) Use in-order traversal to print the nodes in an in-order fashion.                                                                                                                                                                                                               |
|Tree / Binary Tree / Depth-First Search / Recursion                              |E      |[](https://leetcode.com/problems/minimum-distance-between-bst-nodes/)[783](https://leetcode.com/problems/minimum-distance-between-bst-nodes/)                                              |[](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC783-minimumDistanceBetweenBSTNodes.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC783-minimumDistanceBetweenBSTNodes.py)                                        |Minimum Distance Between BST Nodes                       |The reason we do an inorder traversal is because the minimum difference between two nodes will always be between two nodes that are adjacent in sorted order. This similar to LC 285, but we are checking all successors, so a full inorder traversal is necessary. The reason we use a nonlocal variable outside of the dfs function is because the adjacent values aren't always directly connected by one edge, so we can't use something like a parent reference and must keep track of the last evaluated node. Think of how inorder works. Left -> Root -> Right. So it goes deep left, processes left, processes root, then processes right. The next value in the inorder traversal if there a more nodes in the tree is right's parent's parent, since right is in the left subtree of the Left -> Root -> Right traversal.                                                                |Concept: 1) Use in-order traversal with a nonlocal variable tracking the previous node's value to find the minimum difference between two nodes.                                                                                                                                            |
|Tree / Binary Tree / Depth-First Search / Recursion                              |M      |[](https://leetcode.com/problems/binary-search-tree-iterator/)[173](https://leetcode.com/problems/binary-search-tree-iterator/)                                                            |[](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC173-binarySearchTreeIterator.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC173-binarySearchTreeIterator.py)                                                    |Binary Search Tree Iterator                              |To suspend the iterator on the next node, use a stack and populate it with all left nodes until we reach a null node. Then when next() is called, popping the node at the top of the stack will be the next node in the iterator. Then get the node's right reference (if it is not None) and again traverse down to the left, adding each node to the stack. This acts like inorder DFS where we suspend the iterator at the next node.                                                                                                                                                                                                                                                                                                                                                                                                                                                            |Concept: 1) Use a stack to implement iterative in-order traversal.                                                                                                                                                                                                                          |
|Post-order Traversal                                                             |:lemon:|                                                                                                                                                                                           |                                                                                                                                                                                                                                                      |                                                         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |                                                                                                                                                                                                                                                                                            |
|Tree / Binary Tree / Depth-First Search / Recursion                              |E      |[](https://leetcode.com/problems/binary-tree-postorder-traversal/)[145](https://leetcode.com/problems/binary-tree-postorder-traversal/)                                                    |[](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC145-binaryTreePostorderTraversal.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC145-binaryTreePostorderTraversal.py)                                            |Binary Tree Postorder Traversal                          |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |Concept: 1) Use post-order traversal to print the nodes in a tree in a post-order fashion.                                                                                                                                                                                                  |
|Tree / Binary Tree / Depth-First Search / Recursion                              |E      |[](https://leetcode.com/problems/balanced-binary-tree/)[110](https://leetcode.com/problems/balanced-binary-tree/)                                                                          |[](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC110-balancedBinaryTree.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC110-balancedBinaryTree.py)                                                                |Balanced Binary Tree                                     |A somewhat tricky thing to come up with is returning a pair of values for each recursive call. Also note that this approach requires a helper function because isBalanced() returns a bool. So we can't use isBalanced() to pass the pair of values up the tree during recursion and eventually to the original caller which only wants a bool value.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |Concept: 1) Use post-order traversal to compare subtree heights.                                                                                                                                                                                                                            |
|Tree / Binary Tree / Depth-First Search / Recursion                              |M      |[](https://leetcode.com/problems/delete-leaves-with-a-given-value/description/)[1325](https://leetcode.com/problems/delete-leaves-with-a-given-value/description/)                         |[](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC1325-deleteLeavesWithAGivenValue.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC1325-deleteLeavesWithAGivenValue.py)                                            |Delete Leaves With a Given Value                         |Use a postorder traversal. We want postorder so we can remove references of leaf nodes that match the target value starting from the bottom and going up. Since we are reassigning references, we can recursively set root.left and root.right to the respective DFS calls. And since we are assigning infromation to each child, we must return some information. And that infromation is the children nodes. So we encode the case that we want to delete by returning None, which will in turn set root.left or root.right to None if they should be deleted. Otherwise, we return root. And the base case returns None if root is None because we want root.left/root.right to be assigned to None if there is no node.                                                                                                                                                                         |Concept: 1) Use post-order traversal to delete leaf nodes that match a target value. 2) Deleting a leaf node can make its parent a leaf node, making a bottom-up order beneficial.                                                                                                          |
|Tree / Binary Tree / Depth-First Search / Recursion                              |M      |[](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/)[236](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/)                                    |[](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC236-lowestCommonAncestorOfABinaryTree.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC236-lowestCommonAncestorOfABinaryTree.py)                                  |Lowest Common Ancestor of a Binary Tree                  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |Concept: 1) Use post-order traversal to find the LCA of two nodes.                                                                                                                                                                                                                          |
|Tree / Binary Tree / Depth-First Search / Recursion                              |M      |[](https://leetcode.com/problems/count-nodes-equal-to-average-of-subtree/)[2265](https://leetcode.com/problems/count-nodes-equal-to-average-of-subtree/)                                   |[](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC2265-countNodesEqualToAverageOfSubtree.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC2265-countNodesEqualToAverageOfSubtree.py)                                |Count Nodes Equal to Average of Subtree                  |This is a problem that follows the subpattern of processing nodes in a postorder manner. We recurse deeply on the left, then on the right, store whatever information we get from the left and right subtrees into variables, and then use the left and right subtree values we found to compute what the problem is asking for. Important things to note for these types of problems: 1) We return a value in the recursion (a pair of values in this case) even in the base case. 2) We do a preorder traversal and store the values returned by the left and right subtrees in variables 'left' and 'right'. 3) We do a computation on the information we found in the two subtrees. 4) We return a value in the recursion to this execution context's caller (a pair of values in this case).                                                                                                   |Concept: 1) use post-order traversal to find the average of the values of each node's left and right subtrees and compare it against the current node's value.                                                                                                                              |
|Tree / Binary Tree / Depth-First Search / Recursion                              |H      |[](https://leetcode.com/problems/binary-tree-maximum-path-sum/)[124](https://leetcode.com/problems/binary-tree-maximum-path-sum/)                                                          |[](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC124-binaryTreeMaximumPathSum.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC124-binaryTreeMaximumPathSum.py)                                                    |Binary Tree Maximum Path Sum                             |This is considered a postorder traversal because we traverse the left subtree, then right subtree, then we process the current. When returning in the DFS, we get max between cur, cur + left and cur + right because it's more explicit so it's easier to trace and understand, but the singular cur.val is not needed since negatives are changed to 0. If the tree is height-balanced, space complexity is O(logn) for the call stack.                                                                                                                                                                                                                                                                                                                                                                                                                                                           |Concept: 1) Use post-order traversal to find the maximum path sum that goes through every node and its subtrees.                                                                                                                                                                            |
|Level-order Traversal                                                            |:lemon:|                                                                                                                                                                                           |                                                                                                                                                                                                                                                      |                                                         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |                                                                                                                                                                                                                                                                                            |
|Tree / Binary Tree / Breadth-First Search / Recursion                            |M      |[](https://leetcode.com/problems/binary-tree-level-order-traversal/)[102](https://leetcode.com/problems/binary-tree-level-order-traversal/)                                                |[](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC102-binaryTreeLevelOrderTraversal.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC102-binaryTreeLevelOrderTraversal.py)                                          |Binary Tree Level Order Traversal                        |This is a standard BFS traversal on a tree. If you are asked to do some type of processing of a tree structure level-wise, it will always be a BFS traversal. It is nearly identical in form to doing a BFS on a graph.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |Concept: Use level-order traversal to traverse a binary tree.                                                                                                                                                                                                                               |
|Tree / N-ary Tree / Breadth-First Search / Recursion                             |M      |[](https://leetcode.com/problems/n-ary-tree-level-order-traversal/description/)[429](https://leetcode.com/problems/n-ary-tree-level-order-traversal/description/)                          |[](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC429-n-aryTreeLevelOrderTraversal.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC429-n-aryTreeLevelOrderTraversal.py)                                            |N-ary Tree Level Order Traversal                         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |Concept: Use level-order traversal to traverse an n-ary tree.                                                                                                                                                                                                                               |
|Tree / Binary Tree / Breadth-First Search / Recursion                            |M      |[](https://leetcode.com/problems/maximum-level-sum-of-a-binary-tree/)[1161](https://leetcode.com/problems/maximum-level-sum-of-a-binary-tree/)                                             |[](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC1161-maximumLevelSumOfBinaryTree.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC1161-maximumLevelSumOfBinaryTree.py)                                            |Maximum Level Sum of a Binary Tree                       |Make sure the level_sum > max_level_sum check is > not >= because we want the minimum level. If we update based on if they are equal too, we are then taking the maximum level.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |Concept: Use level-order traversal to traverse a binary tree, tracking the sum of all node values of each level.                                                                                                                                                                            |
|Vertical-order Traversal                                                         |:lemon:|                                                                                                                                                                                           |                                                                                                                                                                                                                                                      |                                                         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |                                                                                                                                                                                                                                                                                            |
|Tree / Binary Tree / Hash Map / Depth-First Search / Recursion                   |H      |[](https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/)[987](https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/)                                |[](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC987-verticalOrderTraversalOfABinaryTree.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC987-verticalOrderTraversalOfABinaryTree.py)                              |Vertical Order Traversal of a Binary Tree                |The time complexity comes from the sorting of the columns and the rows when creating the result array that we return. A difficult part of the problem (at least for me) is traversing the dictionary to get the result. Not often are you required to sort keys in a dictionary, so not having this knowledge might push you to a different approach entirely which might be harder to implement. This is why knowing the data structures in your language and how to manipulate them is very important.                                                                                                                                                                                                                                                                                                                                                                                            |Concept: 1) Get the vertical ordering of a binary tree by using a column-to-row mapping. Similar to LC 314.                                                                                                                                                                                 |
|Binary Search Tree                                                               |:lemon:|                                                                                                                                                                                           |                                                                                                                                                                                                                                                      |                                                         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |                                                                                                                                                                                                                                                                                            |
|Tree / Binary Search Tree / Depth-First Search / Recursion                       |E      |[](https://leetcode.com/problems/search-in-a-binary-search-tree/)[700](https://leetcode.com/problems/search-in-a-binary-search-tree/)                                                      |[](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC700-searchInABinarySearchTree.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC700-searchInABinarySearchTree.py)                                                  |Search in a Binary Search Tree                           |For time complexity, it is O(log(N)) if the tree is height-balanced and O(N) if it is not. Using the iterative traversal uses O(1) space because we do not need stack space for the function calls. As for recursion, the worst-case would be if the value we are looking for is a leaf node. No matter what, this scenario would yield a space complexity of O(H) due to the stack frames needed for each function call.                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |Concept: 1) Use binary search to find a target value in a binary search tree.                                                                                                                                                                                                               |
|Tree / Binary Search Tree / Depth-First Search / Recursion                       |M      |[](https://leetcode.com/problems/validate-binary-search-tree/)[98](https://leetcode.com/problems/validate-binary-search-tree/)                                                             |[](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC98-validateBinarySearchTree.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC98-validateBinarySearchTree.py)                                                      |Validate Binary Search Tree                              |All we have to do is keep a running minimum and maximum bound for each recursive call in the DFS as parameters, update them accordingly and check cur.val against them. To evaluate the boolean value of all subtrees, we need evaluate the left and right subtrees at each root. This is a very common subpattern of preorder traversal where we have a base case that returns a result and another case that acts as the processing part for the preorder traversal before dfs on left and right are called. Then we return left AND right, so True is only returned if all subtrees evaluate to True.                                                                                                                                                                                                                                                                                            |Concept: 1) Use preorder traversal to check if each node in a binary search tree is valid. 2) Use boolean evaluation for the return statement.                                                                                                                                              |
|Tree / Binary Search Tree / Depth-First Search / Recursion                       |M      |[](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/)[235](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/)                      |[](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC235-lowestCommonAncestorOfABinarySearchTree.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC235-lowestCommonAncestorOfABinarySearchTree.py)                      |Lowest Common Ancestor of a Binary Search Tree           |Different from finding LCA of a tree that does not have the BST property because we know the upper bound of values in the left subtree and the lower bound of values in the right subtree at each root node of each subtree.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |Concept: 1) Use the BST property to check what subtree a target value is in relation to the current value. 2) Lowest common ancestor.                                                                                                                                                       |
|Tree / Binary Search Tree / Depth-First Search / Recursion                       |M      |[](https://leetcode.com/problems/insert-into-a-binary-search-tree/)[701](https://leetcode.com/problems/insert-into-a-binary-search-tree/)                                                  |[](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC701-insertIntoABinarySearchTree.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC701-insertIntoABinarySearchTree.py)                                              |Insert into a Binary Search Tree                         |The idea for this algorithm is to greedily search for an insert position at a position at the bottom of the tree that will make it a leaf. For the recursive function, there is no need to return anything because we are just updating a reference. For the iterative approach, we can iterate while True because we are guaranteed to reach a leaf node. Both approaches greedily converge to an insert position and look ahead to see if the reference in the correct direction is None.                                                                                                                                                                                                                                                                                                                                                                                                         |Concept: 1) Use binary search to search for an insert position and insert a new node with a given value.                                                                                                                                                                                    |
|Tree / Binary Search Tree / Depth-First Search / Recursion                       |M      |[](https://leetcode.com/problems/convert-bst-to-greater-tree/)[538](https://leetcode.com/problems/convert-bst-to-greater-tree/)                                                            |[](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC538-convertBSTToGreaterTree.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC538-convertBSTToGreaterTree.py)                                                      |Convert BST to Greater Tree                              |This traversal is considered to be reverse inorder traversal. Inorder traversal is Left -> Root -> Right. Reverse inorder is Right -> Root -> Left. To explain why inorder and why reverse: The reason we do inorder traversal because inorder traversal of a BST processes each node in order from smallest to largest. (Keep in mind this is for a BST specifically). And the reason we do it in reverse order is because we want to process the nodes in order from largest to smallest according to the problem statement.                                                                                                                                                                                                                                                                                                                                                                      |Concept: 1) Use reverse in-order traversal to add the postfix sum of the sorted values to each node.                                                                                                                                                                                        |
|Construct Tree                                                                   |:lemon:|                                                                                                                                                                                           |                                                                                                                                                                                                                                                      |                                                         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |                                                                                                                                                                                                                                                                                            |
|Array / Tree / Binary Tree / Depth-First Search / Recursion                      |E      |[](https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/)[108](https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/)                              |[](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC108-convertSortedArrayToBST.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC108-convertSortedArrayToBST.py)                                                      |Convert Sorted Array to BST                              |We have to use the sorted property of the array along with the relationship between values in a binary search tree to solve the problem. For the root of every subtree in a binary search tree, all of the values in the left subtree are less than the root, while all of the values in the right subtree are greater than the root. Since we want a height-balanced tree, we want the left and right subtrees to be of similar height. So we pick the root to be the middle of the array. Then we set the left child and right child of this root as the middle of the left subarray and right subarray respectively. We will do this recursively. The base case is when nums is empty, we return None.                                                                                                                                                                                           |Concept: 1) Convert a sorted array to a binary search tree.                                                                                                                                                                                                                                 |
|Array / Tree / Binary Tree / Depth-First Search / Recursion                      |M      |[](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)[105](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)|[](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC105-constructBinaryTreeFromPreorderAndInorderTraversal.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC105-constructBinaryTreeFromPreorderAndInorderTraversal.py)|Construct Binary Tree from Preorder and Inorder Traversal|More explanation: The global 'preorder_index' is helpful because the preorder value is always the next value in the preorder array after a root is created. Root.left and root.right is fairly trivial now since we are only changing the bound respective to its side and we do not include the root value in each bound.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |Concept: 1) Convert a pre-order array and an in-order array into a binary tree.                                                                                                                                                                                                             |
|Tree / Binary Tree / Depth-First Search / Recursion                              |H      |[](https://leetcode.com/problems/serialize-and-deserialize-binary-tree/)[297](https://leetcode.com/problems/serialize-and-deserialize-binary-tree/)                                        |[](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC297-serializeAndDeserializeBinaryTree.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC297-serializeAndDeserializeBinaryTree.py)                                  |Serialize and Deserialize Binary Tree                    |There are two main ways these functions can be implemented. With DFS and with BFS. I prefer BFS because I think it is way easier to visualize the construction of a tree through BFS. Serialize matches the type of BFS you normally see because it is being done on a tree structure, whereas deserialize is doing BFS on a string. In deserialize it really is just a matter of understanding how to traverse the array to create the nodes and update the references to left and right of each root node. I strongly recommend watching Striver's video (the first 7 minutes) to get a good visualization on how this translation between a tree structure and string is done.                                                                                                                                                                                                                   |Concept: 1) Serialize and deserialize a binary tree.                                                                                                                                                                                                                                        |
|Binary Tree Indices                                                              |:lemon:|                                                                                                                                                                                           |                                                                                                                                                                                                                                                      |                                                         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |                                                                                                                                                                                                                                                                                            |
|Tree / Binary Tree / Hash Set / Depth-First Search / Recursion                   |M      |[](https://leetcode.com/problems/find-elements-in-a-contaminated-binary-tree/description/)[1261](https://leetcode.com/problems/find-elements-in-a-contaminated-binary-tree/description/)   |[](https://github.com/BrandonKenter/Solutions/blob/main/Hash%20Map/LC1261-findElementsInAContaminatedBinaryTree.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Hash%20Map/LC1261-findElementsInAContaminatedBinaryTree.py)            |Find Elements in a Contaminated Binary Tree              |This is similar to problems where you need the index of a node in a tree. One of these other problems is LC 662 - "Maximum Width of Binary Tree". So once we notice that the values of each node in this problem are actually the indices, you just need to know the formulas for calculating them and then this problem becuase fairly trivial. The formulas for each index: Left child = cur val \* 2 + 1. Right child = cur val \* 2 + 2. These indices can be found either with BFS or DFS. Both implementations use a "self.values" set to store visited indices of nodes, which is important to make the find() function an O(1) lookup.                                                                                                                                                                                                                                                      |Concept: 1) Binary tree indices.                                                                                                                                                                                                                                                            |
|Tree / Binary Tree / Depth-First Search / Recursion                              |M      |[](https://leetcode.com/problems/check-completeness-of-a-binary-tree/description/)[958](https://leetcode.com/problems/check-completeness-of-a-binary-tree/description/)                    |[](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC958-checkCompletenessOfABinaryTree.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC958-checkCompletenessOfABinaryTree.py)                                        |Check Completeness of a Binary Tree                      |A helpful trick you can use with binary trees is to calculate the index of each node from top to bottom and left to right. To calculate the node's index in the tree, start the root node at index 0. Then when we call dfs on the children, the left child's index is 2\*i+1, while the right child's index is 2\*i+2. We can use these indices to check if the last node we saw on the last level is equal to the number of nodes seen - 1. To have access to the last node's index in the last level of the tree, update it when we are at the max height/depth of the tree so far. Since dfs traverses the tree left to right, this is guaranteed to be the rightmost node in the last level of the tree.                                                                                                                                                                                       |Concept: 1) Binary tree indices. 2) Complete binary tree definition.                                                                                                                                                                                                                        |
|Build Graph                                                                      |:lemon:|                                                                                                                                                                                           |                                                                                                                                                                                                                                                      |                                                         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |                                                                                                                                                                                                                                                                                            |
|Tree / Binary Tree / Graph / Breadth-First Search                                |M      |[](https://leetcode.com/problems/all-nodes-distance-k-in-binary-tree/)[863](https://leetcode.com/problems/all-nodes-distance-k-in-binary-tree/)                                            |[](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC863-allNodesDistanceKInBinaryTree.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC863-allNodesDistanceKInBinaryTree.py)                                          |All Nodes Distance K in Binary Tree                      |We need a visited hash set in the BFS because we have undirected edges in the new adjacency list. This is an important distinction between trees (no cycles) and undirected graphs (cycles). For populating the adjacency list, DFS is simpler and a better average time complexity (if tree is height-balanced because space complexity is O(log(N)) for the call stack instead of O(N) that the queue in BFS uses). For creating adj list with DFS, use cur and parent parameters and add undirected edge to adjacency list if cur and parent are not None. One thing to think about is how this way avoids duplicate edges. Imagine if you made an entry for left and right child at each DFS call.                                                                                                                                                                                              |Concept: 1) Convert tree to graph. 2) Use breadth-first search to find distance to target value.                                                                                                                                                                                            |
|Tree / N-ary Tree / Graph / Depth-First Search / Breadth-First Search / Recursion|M      |[](https://leetcode.com/problems/reachable-nodes-with-restrictions/description/)[2368](https://leetcode.com/problems/reachable-nodes-with-restrictions/description/)                       |[](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC2368-reachableNodesWithRestrictions.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC2368-reachableNodesWithRestrictions.py)                                      |Reachable Nodes With Restrictions                        |This is a standard DFS/BFS problem with a few extra complexities. The first complexity is checking if a node is restricted or not so we avoid going down this path. To do this efficiently, cast restricted to a set so we can do O(1) lookups for node values. The second complexity is the edges being undirected. Most tree problems provide a tree data structure with ListNodes that have directed edges (left and right typically), so you can only traverse the tree in one direction. But for this problem, we are only provided edges, and these edges are undirected. So when we start from 0 and go down the tree, we have to make sure we aren't going back up the tree and recounting nodes/going into an infinite loop. To avoid this, just use a prev reference for the parent node and make sure the neighbor node we are about to call DFS on isn't the parent of the current node.|Concept: 1) Convert tree to graph. 2) Using prev to avoid traversing already traversed nodes, while also avoiding traversing nodes that are restricted. 3) Know how to do this for DFS and BFS (use prev parameter in DFS method signature and use tuples of (cur, prev) as nodes in queue).|
|Node Relationships                                                               |:lemon:|                                                                                                                                                                                           |                                                                                                                                                                                                                                                      |                                                         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |                                                                                                                                                                                                                                                                                            |
|Tree / Binary Tree / Breadth-First Search / Recursion                            |E      |[](https://leetcode.com/problems/cousins-in-binary-tree/description/)[993](https://leetcode.com/problems/cousins-in-binary-tree/description/)                                              |                                                                                                                                                                                                                                                      |Cousins in Binary Tree                                   |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |Concept: 1) Cousins in a binary tree.                                                                                                                                                                                                                                                       |
|Tree / Binary Tree / Breadth-First Search / Recursion                            |M      |[](https://leetcode.com/problems/sum-of-nodes-with-even-valued-grandparent/)[1315](https://leetcode.com/problems/sum-of-nodes-with-even-valued-grandparent/)                               |[](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC1315-sumOfNodesWithEven-ValuedGrandparent.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Tree/LC1315-sumOfNodesWithEven-ValuedGrandparent.py)                          |Sum of Nodes with Even-Valued Grandparent                |This implementation is an improvement on the slightly naÃ¯ve approach of storing a path array that holds state that describes each node as either even or odd. But this adds an extra O(H) space complexity. For a constant O(1) space complexity, we keep two variables 'parent' and 'grand' to keep track of the even/odd bool for each node's ancestors. A mistake I initially made is trying to update grand to parent before checking 'if grand' in the recursive procedure. We want update grand after 'if grand' because the code assumes parent and grand are already updated before this check.                                                                                                                                                                                                                                                                                             |Concept: 1) Grandparents in a binary tree.                                                                                                                                                                                                                                                  |

## Backtracking

|Permutations                                                             |:lemon:|                                                                                                                                                                                                                |                                                                                                                                                                                                                                                                |                                                       |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |                                                                                                                                                                                                                                                                |
|-------------------------------------------------------------------------|-------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|Array / Depth-First Search / Backtracking / Recursion                    |M      |[](https://leetcode.com/problems/permutations/)[46](https://leetcode.com/problems/permutations/)                                                                                                                |[](https://github.com/BrandonKenter/Solutions/blob/main/Backtracking/LC46-permutations.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Backtracking/LC46-permutations.py)                                                                        |Permutations                                           |Order matters with permutations, whereas order does NOT matter with combinations. This is significant because we then have to make sure every ordering is expressed. To do so, we use an array that encodes whether an element in the input collection has been used or not. The for loop inside of each recursive call tries every position for every element.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |Concept: 1) Generate a list of all the permutations of a given list of numbers.                                                                                                                                                                                 |
|Depth-First Search / Backtracking / Recursion                            |M      |[](https://leetcode.com/problems/beautiful-arrangement/)[526](https://leetcode.com/problems/beautiful-arrangement/)                                                                                             |[](https://github.com/BrandonKenter/Solutions/blob/main/Backtracking/LC526-beautifulArrangement.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Backtracking/LC526-beautifulArrangement.py)                                                      |Beautiful Arrangement                                  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |Concept: 1) Count all of the unique permutations that can be made in a range of numbers that follows a constraint. 2) Implicit collection of elements.                                                                                                          |
|String/ Depth-First Search / Backtracking / Recursion                    |M      |[](https://leetcode.com/problems/letter-case-permutation/)[784](https://leetcode.com/problems/letter-case-permutation/)                                                                                         |[](https://github.com/BrandonKenter/Solutions/blob/main/Backtracking/LC784-letterCasePermutation.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Backtracking/LC784-letterCasePermutation.py)                                                    |Letter Case Permutation                                |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |Concept: 1) Generate all permuations of letter cases in a string. 2) Append number or recurse on choice to use lower case and recurse on choice to use upper case.                                                                                              |
|Matrix                                                                   |:lemon:|                                                                                                                                                                                                                |                                                                                                                                                                                                                                                                |                                                       |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |                                                                                                                                                                                                                                                                |
|Matrix / Hash Set / Depth-First Search / Backtracking / Recursion        |H      |[](https://leetcode.com/problems/n-queens/)[51](https://leetcode.com/problems/n-queens/)                                                                                                                        |[](https://github.com/BrandonKenter/Solutions/blob/main/Backtracking/LC51-N-Queens.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Backtracking/LC51-N-Queens.py)                                                                                |N-Queens                                               |Base case: if r == n, append the board to the result array. Choice: Iterate for col in the range of the number of rows. If the column passes the valid state check, add it to the state. Otherwise, skip this entire if block (prune res of decision tree). Recursive procedure: backtrack(r + 1).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |Concept: 1) Generate all permutations of element placements in a 2D matrix that adheres to the constraints.                                                                                                                                                     |
|Backtracking                                                             |H      |[](https://leetcode.com/problems/sudoku-solver/)[37](https://leetcode.com/problems/sudoku-solver/)                                                                                                              |[](https://github.com/BrandonKenter/Solutions/blob/main/Backtracking/LC37-sudokuSolver.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Backtracking/LC37-sudokuSolver.py)                                                                        |Sudoku Solver                                          |Base case: if r == 9, return True. Constraints: Value in current cell must be unique for its respective row/col/square set and be in the range [1, 9]. Choice: If cell == '.', choose between the values [1, 9] to put in this cell. Pay attention to where the valid state checking is at. For this problem, it is inside the for loop. For word search, it is at the base case. We put it inside the for loop because it is the necessary placement for the execution flow. Why? Because the beginning of the for loop is the entry point for the changing state. This is the first part of the algorithm that sees this new value. The discrepency comes from carrying the state change as a method parameter vs generating it in a for loop. Check if choice meets constraints BEFORE recursing because you can't backtrack from a choice where you add the same number to a set since the set only encodes 1 number and cleaning up this decision by removing it wouldn't work as intended.(Hash map is a workaround, but general idea is to consider checking constraints before recursing).|Concept: 1) Generate a permutations of elements in a 2D matrix that adheres to the constraints. 2) If using a set to track choices, check constraint before making the choice since you can't backtrack from the choice of adding a duplicate number to the set.|
|Combinations                                                             |:lemon:|                                                                                                                                                                                                                |                                                                                                                                                                                                                                                                |                                                       |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |                                                                                                                                                                                                                                                                |
|String / Hash Map / Depth-First Search / Backtracking / Recursion        |M      |[](https://leetcode.com/problems/letter-combinations-of-a-phone-number/)[17](https://leetcode.com/problems/letter-combinations-of-a-phone-number/)                                                              |[](https://github.com/BrandonKenter/Solutions/blob/main/Backtracking/LC17-letterCombinationsOfAPhoneNumber.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Backtracking/LC17-letterCombinationsOfAPhoneNumber.py)                                |Letter Combinations of Phone #                         |We are asked to get every possible letter combination given digits. Since there is no way to avoid enumerating every possible combination, we can think of this problem as exploring all possible states, which tells us we need to use recursion. Our state is described as the index we are at in the digits string as well as the current combination we have built up. Reaching i == len(digits) signifies we have reached a solution state. The index is the only part of our state that can break the problem constraints (by going beyond the last digit in digits). So we don't need any other valid state checking beyond the base case for appending to res. As for our choices, the for loop handles this. For the backtrack, we just need to pop from combo.                                                                                                                                                                                                                                                                                                                          |Concept: 1) Generate all combinations of letters that can be produced from a phone number. 2) Use a hash map to map numbers to letters so each number's possible choices can be iterated over.                                                                  |
|Array / Depth-First Search / Backtracking / Recursion                    |M      |[](https://leetcode.com/problems/combinations/)[77](https://leetcode.com/problems/combinations/)                                                                                                                |[](https://github.com/BrandonKenter/Solutions/blob/main/Backtracking/LC77-combinations.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Backtracking/LC77-combinations.py)                                                                        |Combinations                                           |This is similar to LC 78 - "Subsets" except we want combinations of size k and in the range [1, n].                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |Concept: 1) Generate all combinations with the constraints of combination size and numbers within a range.                                                                                                                                                      |
|Array / Depth-First Search / Backtracking / Recursion                    |M      |[](https://leetcode.com/problems/combination-sum/)[39](https://leetcode.com/problems/combination-sum/)                                                                                                          |[](https://github.com/BrandonKenter/Solutions/blob/main/Backtracking/LC39-combinationSum.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Backtracking/LC39-combinationSum.py)                                                                    |Combination Sum                                        |Our time complexity O(2^N\*N) because we are bounded by N instead of T since we can pick at most N elements if we have an element equal to 1 in the input candidates. The extra N is for copying the combination list we are building up to add it to the output list.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |Concept: 1) Generate all combinations with the constraints of a target combination sum and possible choices being a list of candidates.                                                                                                                         |
|Array / String / Hash Map / Depth-First Search / Backtracking / Recursion|H      |[](https://leetcode.com/problems/maximum-score-words-formed-by-letters/description/)[1255](https://leetcode.com/problems/maximum-score-words-formed-by-letters/description/)                                    |                                                                                                                                                                                                                                                                |Maximum Score Words Formed by Letters                  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |Concept: 1) Generate a combination of words that has a maximum score. 2) Track and backtrack choices using a count hash map for each used character.                                                                                                            |
|Array / Depth-First Search / Backtracking / Recursion                    |M      |[](https://leetcode.com/problems/fair-distribution-of-cookies/)[2305](https://leetcode.com/problems/fair-distribution-of-cookies/)                                                                              |                                                                                                                                                                                                                                                                |Fair Distribution of Cookies                           |Each choice has the potential to put into k buckets. The reason we can't do partition backtracking is because the partitions don't have to be in order. So we instead opt to iterate over the buckets (children) to make a choice to put the current in one of the k buckets.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |Concept: 1) Bucket backtracking.                                                                                                                                                                                                                                |
|Array / Depth-First Search / Backtracking / Recursion                    |M      |[](https://leetcode.com/problems/matchsticks-to-square/)[473](https://leetcode.com/problems/matchsticks-to-square/)                                                                                             |[](https://github.com/BrandonKenter/Solutions/blob/main/Backtracking/LC473-matchsticksToSquare.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Backtracking/LC473-matchsticksToSquare.py)                                                        |Matchsticks to Square                                  |In problems like Sudoku Solver, we are recursing through the input collection (board) and iterating through the choice spcae (numbers 1-10). For this problem, it is slightly different. We are recursing through the input collection (matchsticks array) and iterating through the choice space (position in the state collection). The key thing to understand for this problem is we are essentially trying to find the correct combination of matchsticks for each side (bucket) of the square.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |Concept: 1) Determine if an array partitioned into buckets where each bucket adheres to a constraint.                                                                                                                                                           |
|Partition Sequence                                                       |:lemon:|                                                                                                                                                                                                                |                                                                                                                                                                                                                                                                |                                                       |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |                                                                                                                                                                                                                                                                |
|String / Hash Set / Depth-First Search / Backtracking / Recursion        |M      |[](https://leetcode.com/problems/split-a-string-into-the-max-number-of-unique-substrings/description/)[1593](https://leetcode.com/problems/split-a-string-into-the-max-number-of-unique-substrings/description/)|[](https://github.com/BrandonKenter/Solutions/blob/main/Backtracking/LC1593-splitAStringIntoTheMaxNumberOfUniqueSubstrings.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Backtracking/LC1593-splitAStringIntoTheMaxNumberOfUniqueSubstrings.py)|Split a String Into the Max Number of Unique Substrings|                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |Concept: 1) Generate all partitions of a string that adhere to constraints.                                                                                                                                                                                     |
|String / Depth-First Search / Backtracking / Recursion                   |M      |[](https://leetcode.com/problems/palindrome-partitioning/)[131](https://leetcode.com/problems/palindrome-partitioning/)                                                                                         |[](https://github.com/BrandonKenter/Solutions/blob/main/Backtracking/LC131-palindromePartitioning.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Backtracking/LC131-palindromePartitioning.py)                                                  |Palindrome Partitioning                                |This is similar to Restore IP Addresses in that this is a substring backtracking problem. We want to partition the array into different substrings that adhere to the constraints.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |Concept: 1) Generate all partitions of a string that adhere to constraints. 2) Check if a substring is a palindrome.                                                                                                                                            |
|String / Hash Set / Depth-First Search / Backtracking / Recursion        |H      |[](https://leetcode.com/problems/word-break-ii/description/)[140](https://leetcode.com/problems/word-break-ii/description/)                                                                                     |[](https://github.com/BrandonKenter/Solutions/blob/main/Backtracking/LC140-wordBreakII.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Backtracking/LC140-wordBreakII.py)                                                                        |Word Break II                                          |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |Concept: 1) Generate all partitions of a string that adhere to constraints.                                                                                                                                                                                     |
|Generate Sequence                                                        |:lemon:|                                                                                                                                                                                                                |                                                                                                                                                                                                                                                                |                                                       |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |                                                                                                                                                                                                                                                                |
|Depth-First Search / Backtracking / Recursion                            |M      |[](https://leetcode.com/problems/numbers-with-same-consecutive-differences/description/)[967](https://leetcode.com/problems/numbers-with-same-consecutive-differences/description/)                             |[](https://github.com/BrandonKenter/Solutions/blob/main/Backtracking/LC967-numbersWithSameConsecutiveDifferences.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Backtracking/LC967-numbersWithSameConsecutiveDifferences.py)                    |Numbers With Same Consecutive Differences              |There are a lot of people who classify their solutions as DFS or use BFS of some kind, but this problem is designed for backtracking (yes, DFS and backtracking are often used interchangeably for problems that explore all possibilities). I think my solution is by far the easiest to use for most other backtracking problems since it fits my backtracking template.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |Concept: 1) Generate all sequences that adhere to constraints.                                                                                                                                                                                                  |
|Subsets                                                                  |:lemon:|                                                                                                                                                                                                                |                                                                                                                                                                                                                                                                |                                                       |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |                                                                                                                                                                                                                                                                |
|Array / Depth-First Search / Backtracking / Recursion                    |M      |[](https://leetcode.com/problems/subsets/)[78](https://leetcode.com/problems/subsets/)                                                                                                                          |[](https://github.com/BrandonKenter/Solutions/blob/main/Backtracking/LC78-subsets.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Backtracking/LC78-subsets.py)                                                                                  |Subsets                                                |For subsets, order does not matter. So [1, 2] is considered to be the same as [2, 1]. This is considered to be a problem that a brute-force approach cannot be avoided because we have to generate all subsets. There is no way to shortcut the generation of 2^N subsets. Why is there 2^N subsets for a list of unique elements? Because at every index, we can choose to 1) include the element or 2) skip the element. This is two choices at each index. So 2^N possible choices. If the output array is considered as a part of the space comlexity, it is O(2^N^2).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |Concept: 1) Generate all subsets of a given list of numbers.                                                                                                                                                                                                    |
|Array / Depth-First Search / Backtracking / Recursion                    |M      |[](https://leetcode.com/problems/subsets-ii/)[90](https://leetcode.com/problems/subsets-ii/)                                                                                                                    |[](https://github.com/BrandonKenter/Solutions/blob/main/Backtracking/LC90-subsetsII.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Backtracking/LC90-subsetsII.py)                                                                              |Subsets II                                             |This is similar to LC 78 - "Subsets" with one difference: there can be duplicate values in the input array nums. So it isn't sufficient to just do the same approach as in LC 78. If we have an input array of [1, 2, 2], the previous approach will add duplicate subsets such as [1, 2] and [1, 2] because we can pick either of the two 2's. To avoid duplicates, we must adjust our pick/not pick logic. If we pick an element, we can pick that element's value again in the future for this path. But if we skip it, we must skip all future elements equal to this value. To help with this, we sort the input array nums. Order doesn't matter. Pick or don't pick. If not picking element, skip all instances of this element. Sort at beginning.                                                                                                                                                                                                                                                                                                                                        |Concept: 1) Generate all unique subsets of a given list of numbers that may contain duplicates. 2) Presorting to make a decision based on adjacent numbers in sorted order.                                                                                     |
|Search                                                                   |:lemon:|                                                                                                                                                                                                                |                                                                                                                                                                                                                                                                |                                                       |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |                                                                                                                                                                                                                                                                |
|Matrix / Hash Set / Depth-First Search / Backtracking / Recursion        |M      |[](https://leetcode.com/problems/word-search/)[79](https://leetcode.com/problems/word-search/)                                                                                                                  |[](https://github.com/BrandonKenter/Solutions/blob/main/Backtracking/LC79-wordSearch.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Backtracking/LC79-wordSearch.py)                                                                            |Word Search                                            |Base cases: If we reach end of word or the current (r, c) cell is not valid. Constraints: Char in the current cell must match the current index of the word. Choice: Go up, down, left or right from the current cell if the current cell's char matches the current index of the word. For the time complexity: it is 3^L where L is the length of the word because we won't recurse on a visited cell, so that leaves us with at most 3 options in direciton.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |Concept: 1) Search for a sequence of elements in a 2D matrix.                                                                                                                                                                                                   |
|Matrix / Hash Set / Depth-First Search / Backtracking / Recursion        |H      |[](https://leetcode.com/problems/unique-paths-iii/description/)[980](https://leetcode.com/problems/unique-paths-iii/description/)                                                                               |Code                                                                                                                                                                                                                                                            |Unique Paths III                                       |The is a "number of ways" recursion subpattern. For the base cases, if the condition is not met, we return 0. If it is met, we return 1. Then for the recursive procedure we have the paths variable starting at 0 and add to it the return value of each dfs call. Make sure we add to cur_vis before calling dfs on this cell, then remove from cur_vis when the calls return and return the paths array to its parent calls.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |Concept: 1) Number of ways to arrive at a destination with up, down, left and right moves. 2) Matrix search backtracking.                                                                                                                                       |

## Binary Search

|Binary Search                                |       |                                                                                                                                                                                                              |                                                                                                                                                                                                                                                                  |                                                       |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |                                                                                                                                                                                                                 |
|---------------------------------------------|-------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|Element Search                               |:lemon:|                                                                                                                                                                                                              |                                                                                                                                                                                                                                                                  |                                                       |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |                                                                                                                                                                                                                 |
|Array / Binary Search / Two Pointers         |E      |[](https://leetcode.com/problems/binary-search/)[704](https://leetcode.com/problems/binary-search/)                                                                                                           |[](https://github.com/BrandonKenter/Solutions/blob/main/Binary%20Search/LC704-binarySearch.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Binary%20Search/LC704-binarySearch.py)                                                                  |Binary Search                                          |This is the target subpattern because we are looking for a specific element to see if it exists in the array or not. So we can do a standard binary search while left <= right and updating the search space based on what the element's value is at our pivot index mid in comparison to our target value.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |Concept: 1) Use binary search to find an explicit value in a sorted collection of elements.                                                                                                                      |
|Binary Search / Two Pointers                 |E      |[](https://leetcode.com/problems/guess-number-higher-or-lower/)[374](https://leetcode.com/problems/guess-number-higher-or-lower/)                                                                             |[](https://github.com/BrandonKenter/Solutions/blob/main/Binary%20Search/LC374-guessNumberHigherOrLower.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Binary%20Search/LC374-guessNumberHigherOrLower.py)                                          |Guess Number Higher or Lower                           |This is a standard binary search for a target number with the slight added complexity of using an API to determine the mid's relation to the target. The Target/Contains subpattern either finds the target and returns or updates the search space based on the target.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |Concept: 1) Use binary search to find an explicit value in a sorted implicit collection of elements.                                                                                                             |
|Matrix / Binary Search / Two Pointers        |M      |[](https://leetcode.com/problems/search-a-2d-matrix/)[74](https://leetcode.com/problems/search-a-2d-matrix/)                                                                                                  |[](https://github.com/BrandonKenter/Solutions/blob/main/Binary%20Search/LC704-binarySearch.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Binary%20Search/LC704-binarySearch.py)                                                                  |Search a 2D Matrix                                     |This is a target subpattern because we are looking for a specific element to see if it exists in the 2D matrix or not. We first look for the row using top and bottom pointers (break when found since we can't return early unless this is in its own function). To get the row we can do the mid calculation again, or we can store the mid in a variable outside of the while loop. Then from the second binary search on the row, we use left and right pointers to get the column and return True if the element is found or False if the while loop terminates without finding the element. We don't need to have an overflow-friendly mid calculation because of the constraints of m and n in this problem, but this should always be discussed in an interview.                                                                                                                                                                      |Concept: 1) Use binary search to find an explicit value in a sorted collection of elements in a 2D matrix.                                                                                                       |
|Array / Binary Search / Two Pointers         |M      |[](https://leetcode.com/problems/search-in-rotated-sorted-array/)[33](https://leetcode.com/problems/search-in-rotated-sorted-array/)                                                                          |[](https://github.com/BrandonKenter/Solutions/blob/main/Binary%20Search/LC33-searchInRotatedSortedArray.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Binary%20Search/LC33-searchInRotatedSortedArray.py)                                        |Search in Rotated Sorted Array                         |The first thing that should come to mind when hearing search in a sorted array is binary search. But, we have added complexity with the array being rotated. The binary search can be augmented by first checking which sorted portion of the array our pivot value 'mid' is in. To do this, we do the 'if nums[left] <= nums[mid]' check. Then we check target against nums[mid] and the left/right boundary depending on what sorted portion we determined we were in at the last step. If the left pointer crosses the right pointer without us finding the target, we can return -1. This is the same as returning T/F if the number can be found or not, which is why this is considered to be the "contains" subpattern for binary search.                                                                                                                                                                                              |Concept: 1) Use binary search to find an explicit value in a sorted collection of elements that is rotated.                                                                                                      |
|Array / Binary Search / Two Pointers         |M      |[](https://leetcode.com/problems/find-peak-element/)[162](https://leetcode.com/problems/find-peak-element/)                                                                                                   |[](https://github.com/BrandonKenter/Solutions/blob/main/Binary%20Search/LC162-findPeakElement.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Binary%20Search/LC162-findPeakElement.py)                                                            |Find Peak Element                                      |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |Concept: 1) Use binary search to find a value with a specific relation to its adjacent values.                                                                                                                   |
|Array / Binary Search / Two Pointers         |M      |[](https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/)[34](https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/)                        |[](https://github.com/BrandonKenter/Solutions/blob/main/Binary%20Search/LC34-findFirstAndLastPositionOfElementInSortedArray.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Binary%20Search/LC34-findFirstAndLastPositionOfElementInSortedArray.py)|Find First and Last Position of Element in Sorted Array|Both templates are appropriate for this problem, but the first template is a bit easier to implement because template 2 requires more edge case handling.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |Concept: Use binary search to find the leftmost and rightmost instances of a target value.                                                                                                                       |
|Condition Search                             |:lemon:|                                                                                                                                                                                                              |                                                                                                                                                                                                                                                                  |                                                       |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |                                                                                                                                                                                                                 |
|Array / Binary Search / Two Pointers         |E      |[](https://leetcode.com/problems/search-insert-position/)[35](https://leetcode.com/problems/search-insert-position/)                                                                                          |[](https://github.com/BrandonKenter/Solutions/blob/main/Binary%20Search/LC35-searchInsertPosition.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Binary%20Search/LC35-searchInsertPosition.py)                                                    |Search Insert Position                                 |Template 2: The True side starts at the first number that is greater than or equal to the target. The case where the target exists is obvious, but when the target doesn't exist, we want to insert it after the number below it and before the number higher than it. Since the insert position has to be AFTER the number lower than it, the case where nums[mid] > target, we use the right = mid statement.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |Concept: 1) Use binary search to find the insert position of an element.                                                                                                                                         |
|Array / Binary Search / Two Pointers         |E      |[](https://leetcode.com/problems/maximum-count-of-positive-integer-and-negative-integer/description/)[2529](https://leetcode.com/problems/maximum-count-of-positive-integer-and-negative-integer/description/)|                                                                                                                                                                                                                                                                  |Maximum Count of Positive Integer and Negative Integer |Make sure to start right index as len(nums) because there can be cases where the index that represents the start of the positive numbers doesn't exist, which would allow us to do len(nums) - right (which would be len(nums)) to calculate the number of positive numbres, which ends up being 0.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |Concept: 1) Use binaary search to find the ending position of the negative numbers and the starting position of the positive numbers.                                                                            |
|Array / Binary Search / Two Pointers / Prefix|E      |[](https://leetcode.com/problems/longest-subsequence-with-limited-sum/)[2389](https://leetcode.com/problems/longest-subsequence-with-limited-sum/)                                                            |[](https://github.com/BrandonKenter/Solutions/blob/main/Binary%20Search/LC2389-longestSubsequenceWithLimitedSum.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Binary%20Search/LC2389-longestSubsequenceWithLimitedSum.py)                        |Longest Subsequence With Limited Sum                   |We can sort the array and then we are able to greedily include elements in the sequence from left to right. This greedy approach guarantees the longest subsequence for the desired query sum because we are adding the least amount to the sum at each index starting from the left. It is the "less or equal" subpattern because we are updating our longest we have so far by changing the index if val < query. And in the case where val == query, we can break because it will be the longest subsequence.                                                                                                                                                                                                                                                                                                                                                                                                                              |Concept: 1) Use binary search with prefix sums to find the first value that satisfies a condition (first prefix sum that is greater than queries[i]).                                                            |
|Array / Binary Search / Two Pointers         |M      |[](https://leetcode.com/problems/peak-index-in-a-mountain-array/)[852](https://leetcode.com/problems/peak-index-in-a-mountain-array/)                                                                         |[](https://github.com/BrandonKenter/Solutions/blob/main/Binary%20Search/LC852-peakIndexInAMountainArray.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Binary%20Search/LC852-peakIndexInAMountainArray.py)                                        |Peak Index in a Mountain Array                         |To fit a binary search template, we can't use template 1 because there is no easy way to implement the logic where we make a decision to search to the left or right since we don't have a target value and the array isn't totally sorted. So we instead opt for template 2. With every problem in template 2, we force our thinking by starting on the right side being the True condition. The goal is to find the pair of values where two consecutive values go from increasing to decreasing. The middle value is the peak index. From the right, the True condition can be arr[mid] < arr[mid-1]. This means the final True will have arr[right] as arr[mid], which is the leftmost occurrence where arr[mid] < arr[mid-1].                                                                                                                                                                                                            |Concept: 1) Use binary search to find the first element that satisfies a condition in an explicit collection of elements. 2) Compare current value to value to its left.                                         |
|Array / Binary Search / Two Pointers         |M      |[](https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/description/)[1011](https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/description/)                              |[](https://github.com/BrandonKenter/Solutions/blob/main/Binary%20Search/LC1011-capacityToShipPackagesWithinDDays.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Binary%20Search/LC1011-capacityToShipPackagesWithinDDays.py)                      |Capacity To Ship Packages Within D Days                |This is like LC 875, Koko eating bananas problem. We are searching for the least value that satisfies a condition. It's a subset of binary search that is O(Nlog(N)) time complexity because we have to make a guess, do O(N) time computations, then decrease the search space by half. This is bisect left.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |Concept: 1) Use binary search to find the first element in an implicit collection of elements (weight capacity) that satisfies a constraint (number of days to ship all packages with "mid" weight is <= "days").|
|Array / Binary Search / Two Pointers         |M      |[](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/)[153](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/)                                                             |[](https://github.com/BrandonKenter/Solutions/blob/main/Binary%20Search/LC153-findMinimumInRotatedSortedArray.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Binary%20Search/LC153-findMinimumInRotatedSortedArray.py)                            |Find Minimum in Rotated Sorted Array                   |With rotated sorted array binary search, we have to identify if we are in the left sorted portion or right sorted portion at each iteration. Unlike LC 33 - "Search in a Rotated Sorted Array", this is the only thing we have to check in terms of adjusting our search space at each iteration. In LC 33 we also had to compare the target value against the number at mid and left, but in this problem we aren't looking for a target - just the minimum value. So it is sufficient to just check if nums[left] is less than or equal to nums[mid] to adjust our search space. However, there is one edge case that we have to consider. We can be in the right sorted portion where our left index holds the min value. In this case our nums[left] <= nums[mid] would incorrectly ignore it and update the search space to left = mid + 1. To avoid this, we set a check at the beginning of each iteration if nums[left] < nums[right].|Concept: 1) Use binary search to find the first element in a rotated sortedarray that is smaller or equal to the element to its right.                                                                           |
|Misc                                         |:lemon:|                                                                                                                                                                                                              |                                                                                                                                                                                                                                                                  |                                                       |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |                                                                                                                                                                                                                 |
|Array / Binary Search / Two Pointers         |H      |[](https://leetcode.com/problems/median-of-two-sorted-arrays/)[4](https://leetcode.com/problems/median-of-two-sorted-arrays/)                                                                                 |                                                                                                                                                                                                                                                                  |Median of Two Sorted Arrays                            |Things to know: median of even length array is middle two elements / 2, while median of odd length array is middle element.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |Concept: 1) Binary search two sorted collections of elements.                                                                                                                                                    |

## Heap

|Greedy                          |:lemon:|                                                                                                                                                                                                    |                                                                                                                                                                                                                                      |                                                 |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |                                                                                                                                                                                                                                                                                                                                                                                               |
|--------------------------------|-------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|Array / Heap / Hash Map / Greedy|M      |[](https://leetcode.com/problems/distant-barcodes/description/)[1054](https://leetcode.com/problems/distant-barcodes/description/)                                                                  |                                                                                                                                                                                                                                      |Distant Barcodes                                 |Very similar to LC 767: Reorganize String.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |Concept: 1) Use max heap to get element with maximum frequency element where the element counts are dynamically changing. 2) Get max frequency element at each step to minimize chance of needing to use same element twice in a row in the future. 3) Pop from heap twice if the current maximum frequency element is equal to the previous selected element to avoid equal adjacent elements.|
|Array / Heap / Greedy           |M      |[](https://leetcode.com/problems/minimum-operations-to-halve-array-sum/description/)[2208](https://leetcode.com/problems/minimum-operations-to-halve-array-sum/description/)                        |[](https://github.com/BrandonKenter/Solutions/blob/main/Heap/LC2208-minimumOperationsToHalveArraySum.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Heap/LC2208-minimumOperationsToHalveArraySum.py)                  |Minimum Operations to Halve Array Sum            |Intuitively it makes sense that if we want to decrease a sum with the minimum number of operations, we pick the biggest numbers first. And that is what we do. Since we are picking numbers, altering them, and then adding them back into a sorted collection of elements, this follows the benefits of a heap.                                                                                                                                                                                                                                                                                                                                             |Concept: 1) Use a max heap to greedily retrieve the maximum value element to halve, which maximizes the depletion rate, thus minimizing the total number of operations.                                                                                                                                                                                                                        |
|Heap / Greedy                   |M      |[](https://leetcode.com/problems/maximum-score-from-removing-stones/description/)[1753](https://leetcode.com/problems/maximum-score-from-removing-stones/description/)                              |[](https://github.com/BrandonKenter/Solutions/blob/main/Heap/LC1753-maximumScoreFromRemovingStones.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Heap/LC1753-maximumScoreFromRemovingStones.py)                      |Maximum Score From Removing Stones               |This follows the common problem pattern where we are getting the min/max from a collection of elements, altering them, and then adding them back to the collection of elements multiple times. This problem pattern uses a heap data structure to do this efficiently.                                                                                                                                                                                                                                                                                                                                                                                       |Concept: 1) Use a max heap to greedily retrieve the max element in a collection of elements to maximize the sum.                                                                                                                                                                                                                                                                               |
|Kth Largest / Smallest          |:lemon:|                                                                                                                                                                                                    |                                                                                                                                                                                                                                      |                                                 |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |                                                                                                                                                                                                                                                                                                                                                                                               |
|Array / Heap                    |M      |[](https://leetcode.com/problems/find-the-kth-largest-integer-in-the-array/)[1985](https://leetcode.com/problems/find-the-kth-largest-integer-in-the-array/)                                        |[](https://github.com/BrandonKenter/Solutions/blob/main/Heap/LC1985-findTheKthLargestIntegerInTheArray.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Heap/LC1985-findTheKthLargestIntegerInTheArray.py)              |Find the Kth Largest Integer in the Array        |Important note: The wording for these problems can often be confusing. Kth largest means the kth element in a sorted collection of elements. For max heap, we heapify the entire array first so that the heap is in increasing to decreasing order. This means k pops will get our answer. For a min heap, we are making sure no more than k numbers are in the heap. After each push/pop, the kth + 1 largest element will be evicted from the heap. Max heap is O(KlogN + N) and min heap is O(NlogK). When K >= n/2, O(NlogK) will be better than O(KlogN + N).                                                                                           |Concept: 1) Use a min heap of size k, popping from the heap when the size is k + 1. The next pop after the last integer is added is the Kth largest integer. 2) Heapify the given array to make it a max heap and the Kth pop is the Kth largest integer.                                                                                                                                      |
|Matrix / Heap                   |M      |[](https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/)[378](https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/)                                             |                                                                                                                                                                                                                                      |Kth Smallest Element in a Sorted Matrix          |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |Concept: 1) Use a max heap of size k, popping from the heap when the size is k + 1. The next pop after the last integer is added is the Kth smallest integer. 2) Heapify the given array to make it a min heap and the Kth pop is the Kth smallest integer.                                                                                                                                    |
|K Largest / Smallest            |:lemon:|                                                                                                                                                                                                    |                                                                                                                                                                                                                                      |                                                 |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |                                                                                                                                                                                                                                                                                                                                                                                               |
|Array / String / Heap           |E      |[](https://leetcode.com/problems/find-subsequence-of-length-k-with-the-largest-sum/description/)[2099](https://leetcode.com/problems/find-subsequence-of-length-k-with-the-largest-sum/description/)|[](https://github.com/BrandonKenter/Solutions/blob/main/Heap/LC2099-findSubsequenceOfLengthKWithTheLargestSum.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Heap/LC2099-findSubsequenceOfLengthKWithTheLargestSum.py)|Find Subsequence of Length K With the Largest Sum|To find the subsequence, we need to find the k largest numbers in nums. To do this we could sort or use a min heap. Sorting is O(Nlog(N)) time, while using a min heap is O(Nlog(K)) time because we can pop from the min heap when the min heap length is > k (popping the smallest value), meaning pushing and popping is at most log(K) time and we do this N times. Then to recover the subsequence IN ORDER, we just need to get the counts of each value in the min heap, lienarly iterate through the nums array and when we see a num that is in the count hash map, add it to the result list and decrement the count of that value in the hash map.|Concept: 1) Use a min heap of size K to get a collection of the K largest elements. 2) If subsequence sum is the only concern, the order of the elements in the subsequence does not matter.                                                                                                                                                                                                   |
|Array / String / Hash Map / Heap|M      |[](https://leetcode.com/problems/top-k-frequent-words/)[692](https://leetcode.com/problems/top-k-frequent-words/)                                                                                   |                                                                                                                                                                                                                                      |Top K Frequent Words                             |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |Concept: 1) To get K most frequent, use counter and pop k most.                                                                                                                                                                                                                                                                                                                                |
|Min / Max Element               |:lemon:|                                                                                                                                                                                                    |                                                                                                                                                                                                                                      |                                                 |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |                                                                                                                                                                                                                                                                                                                                                                                               |
|Array / Heap                    |E      |[](https://leetcode.com/problems/last-stone-weight/)[1046](https://leetcode.com/problems/last-stone-weight/)                                                                                        |[](https://github.com/BrandonKenter/Solutions/blob/main/Heap/LC1046-lastStoneWeight.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Heap/LC1046-lastStoneWeight.py)                                                    |Last Stone Weight                                |We are deleting and adding to an sorted ordering of numbers. This follows the criteria for a problem pattern that tends to require a heap to solve it optimally. Getting the largest or smallest element repeatedly leans toward a heap solution.                                                                                                                                                                                                                                                                                                                                                                                                            |Concept: 1) Use a max heap to retrieve the max two elements from a collection of elements repeatedly.                                                                                                                                                                                                                                                                                          |
|Array / Hash Map / Heap         |M      |[](https://leetcode.com/problems/least-number-of-unique-integers-after-k-removals/description/)[1481](https://leetcode.com/problems/least-number-of-unique-integers-after-k-removals/description/)  |                                                                                                                                                                                                                                      |Least Number of Unique Integers after K Removals |Good greedy heap problem. Uses the pattern of counts hash map + heap.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |Concept: 1) Counts hash map. 2) Use a min heap to greedily retrieve the minimum count element to decrease.                                                                                                                                                                                                                                                                                     |
|Array / Heap                    |M      |[](https://leetcode.com/problems/single-threaded-cpu/)[1834](https://leetcode.com/problems/single-threaded-cpu/)                                                                                    |                                                                                                                                                                                                                                      |Single-Threaded CPU                              |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |                                                                                                                                                                                                                                                                                                                                                                                               |
|K Lists                         |:lemon:|                                                                                                                                                                                                    |                                                                                                                                                                                                                                      |                                                 |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |                                                                                                                                                                                                                                                                                                                                                                                               |
|Linked List / Heap              |H      |[](https://leetcode.com/problems/merge-k-sorted-lists/)[23](https://leetcode.com/problems/merge-k-sorted-lists/)                                                                                    |                                                                                                                                                                                                                                      |Merge k Sorted Lists                             |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |Concept: 1) K lists min heap.                                                                                                                                                                                                                                                                                                                                                                  |
|Array / Heap                    |H      |[](https://leetcode.com/problems/smallest-range-covering-elements-from-k-lists/)[632](https://leetcode.com/problems/smallest-range-covering-elements-from-k-lists/)                                 |                                                                                                                                                                                                                                      |Smallest Range from K Lists                      |To get the minimum range, we can start by choosing the minimum of each list. The next step is to remove the minimum value between the k lists and consider its next element. Moving the minimum index to the right guarantees we are checking possible pairings that have the smallest range.                                                                                                                                                                                                                                                                                                                                                                |Concept: 1) K lists min heap.                                                                                                                                                                                                                                                                                                                                                                  |
|Misc                            |:lemon:|                                                                                                                                                                                                    |                                                                                                                                                                                                                                      |                                                 |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |                                                                                                                                                                                                                                                                                                                                                                                               |
|Array / Heap                    |M      |[](https://leetcode.com/problems/process-tasks-using-servers/)[1882](https://leetcode.com/problems/process-tasks-using-servers/)                                                                    |                                                                                                                                                                                                                                      |Process Tasks Using Servers                      |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |Concept: 1) Two heaps.                                                                                                                                                                                                                                                                                                                                                                         |
|Heap                            |H      |[](https://leetcode.com/problems/find-median-from-data-stream/)[295](https://leetcode.com/problems/find-median-from-data-stream/)                                                                   |[](https://github.com/BrandonKenter/Solutions/blob/main/Heap/LC295-findMedianFromDataStream.py)[Code](https://github.com/BrandonKenter/Solutions/blob/main/Heap/LC295-findMedianFromDataStream.py)                                    |Find Median from Data Stream                     |Finding the median in an array of numbers is simple, but complexity is added if the array of numbers is instead a stream of numbers, and finding the median is a frequent operation. This is when we want to efficiently have access to the median of the array of values without having to traverse all N values. This is where the concept of using a min and max heap together to separate the stream of values into two parts and every time a number is added, work is done to maintain these halves.                                                                                                                                                   |Concept: 1) Use min and max heap to find the median value in a data stream.                                                                                                                                                                                                                                                                                                                    |

